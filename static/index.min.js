/* begin: ../../../libs/islands/common.blocks/i-jquery/__inherit/i-jquery__inherit.js */
/**
 * @module inherit
 * @version 2.2.3
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @description This module provides some syntax sugar for "class" declarations, constructors, mixins,
 *              "super" calls and static members.
 * License: https://github.com/dfilatov/inherit/blob/2.2.3/LICENSE.md
 */

(function($) {
var emptyBase = function() {},
    objCreate = Object.create || function(ptp) {
        var Inheritance = function() {};
        Inheritance.prototype = ptp;
        return new Inheritance();
    },
    objKeys = Object.keys,
    extend = $.extend,
    isArray = Array.isArray,
    isFunction = $.isFunction,
    needCheckProps = true,
    testPropObj = {toString: ''};

for(var i in testPropObj) { // IE skips "toString" and "valueOf" in a for-in loop
    testPropObj.hasOwnProperty(i) && (needCheckProps = false);
}

var specProps = needCheckProps ? ['toString', 'valueOf'] : null;

function getPropList(obj) {
    var res = objKeys(obj);
    if(needCheckProps) {
        var specProp, i = 0;
        while(specProp = specProps[i++]) { // jshint ignore:line
            obj.hasOwnProperty(specProp) && res.push(specProp);
        }
    }

    return res;
}

function override(base, res, add) {
    var addList = getPropList(add),
        j = 0, len = addList.length,
        name, prop;
    while(j < len) {
        if((name = addList[j++]) === '__self') {
            continue;
        }
        prop = add[name];
        res[name] = isFunction(prop) && prop.toString().indexOf('.__base') > -1
            ? rewriteBase(name, prop)
            : prop;
    }
    function rewriteBase(name, prop) {
        var result = function() {
            var baseSaved = this.__base;

            this.__base = result.__base;
            var res = prop.apply(this, arguments);
            this.__base = baseSaved;

            return res;
        };
        result.__base = base[name]
            ? base[name]
            : name === '__constructor'
                ? res.__self.__parent // Case of inheritance from plain function
                : $.noop;

        return result;
    }
}

function applyMixins(mixins, res) {
    var i = 1, mixin;
    while(mixin = mixins[i++]) { // jshint ignore:line
        if(res) {
            isFunction(mixin)
                ? $.inheritSelf(res, mixin.prototype, mixin)
                : $.inheritSelf(res, mixin);
        } else {
            res = isFunction(mixin)
                ? $.inherit(mixins[0], mixin.prototype, mixin)
                : $.inherit(mixins[0], mixin);
        }
    }
    return res || mixins[0];
}

/**
 * Creates class
 * @exports
 * @param {Function|Array} [baseClass|baseClassAndMixins] class (or class and mixins) to inherit from
 * @param {Object} [prototypeFields]
 * @param {Object} [staticFields]
 * @returns {Function} class
 */
$.inherit = function() {
    var args = arguments,
        withMixins = isArray(args[0]),
        hasBase = withMixins || isFunction(args[0]),
        base = hasBase
            ? (withMixins ? applyMixins(args[0]) : args[0])
            : emptyBase,
        props = args[hasBase ? 1 : 0] || {},
        staticProps = args[hasBase ? 2 : 1],
        res = props.__constructor || (hasBase && base.prototype.__constructor)
            ? function() { return this.__constructor.apply(this, arguments); }
            : hasBase
                ? function() { return base.apply(this, arguments); }
                : function() {};

    if(!hasBase) {
        res.prototype = props;
        res.prototype.__self = res.prototype.constructor = res;
        return extend(res, staticProps);
    }

    extend(res, base);

    res.__parent = base;

    var basePtp = base.prototype,
        resPtp = res.prototype = objCreate(basePtp);

    resPtp.__self = resPtp.constructor = res;

    props && override(basePtp, resPtp, props);
    staticProps && override(base, res, staticProps);

    return res;
};

$.inheritSelf = function() {
    var args = arguments,
        withMixins = isArray(args[0]),
        base = withMixins ? applyMixins(args[0], args[0][0]) : args[0],
        props = args[1],
        staticProps = args[2],
        basePtp = base.prototype;

    props && override(basePtp, basePtp, props);
    staticProps && override(base, base, staticProps);

    return base;
};
})(jQuery);

/* end: ../../../libs/islands/common.blocks/i-jquery/__inherit/i-jquery__inherit.js */
/* begin: ../../../libs/islands/common.blocks/i-jquery/__identify/i-jquery__identify.js */
/**
 * Identify plugin
 *
 * @version 1.0.0
 */

(function($) {
var counter = 0,
    expando = '__' + Number(new Date()),
    get = function() {
        return 'uniq' + (++counter);
    };

/**
 * Makes unique ID
 * @param {Object} [obj] Object that needs to be identified
 * @param {Boolean} [onlyGet=false] Return a unique value only if it had already been assigned before
 * @returns {String} ID
 */
$.identify = function(obj, onlyGet) {
    if(!obj) { return get(); }

    var key = 'uniqueID' in obj ? 'uniqueID' : expando; // Use when possible. native uniqueID for elements in IE

    return onlyGet || key in obj ?
        obj[key] :
        obj[key] = get();
};
})(jQuery);

/* end: ../../../libs/islands/common.blocks/i-jquery/__identify/i-jquery__identify.js */
/* begin: ../../../libs/islands/common.blocks/i-jquery/__observable/i-jquery__observable.js */
/**
 * Observable plugin
 *
 * Copyright (c) 2010 Filatov Dmitry (alpha@zforms.ru)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * @version 1.0.0
 * @requires $.identify
 * @requires $.inherit
 */

 /* jshint maxparams: 6, maxdepth: 9, eqeqeq: false */

(function($) {
var storageExpando = '__' + Number(new Date()) + 'storage',
    getFnId = function(fn, ctx) {
        return $.identify(fn) + (ctx ? $.identify(ctx) : '');
    },
    Observable = /** @lends $.observable.prototype */{

        /**
         * Builds full event name
         * @protected
         * @param {String} e Event type
         * @returns {String}
         */
        buildEventName: function(e) {
            return e;
        },

        /**
         * Adding event handler
         * @param {String} e Event type
         * @param {Object} [data] Additional data that the handler gets as e.data
         * @param {Function} fn Handler
         * @param {Object} [ctx] Handler context
         * @returns {$.observable}
         */
        on: function(e, data, fn, ctx, _special) {
            if(typeof e == 'string') {
                if($.isFunction(data)) {
                    ctx = fn;
                    fn = data;
                    data = undefined;
                }

                var id = getFnId(fn, ctx),
                    storage = this[storageExpando] || (this[storageExpando] = {}),
                    eList = e.split(' '),
                    i = 0,
                    eStorage;

                while((e = eList[i++])) {
                    e = this.buildEventName(e);
                    eStorage = storage[e] || (storage[e] = {ids: {}, list: {}});

                    if(!(id in eStorage.ids)) {
                        var list = eStorage.list,
                            item = {fn: fn, data: data, ctx: ctx, special: _special};
                        if(list.last) {
                            list.last.next = item;
                            item.prev = list.last;
                        } else {
                            list.first = item;
                        }

                        eStorage.ids[id] = list.last = item;
                    }
                }
            } else {
                var self = this;
                $.each(e, function(e, fn) {
                    self.on(e, fn, data, _special);
                });
            }
            return this;
        },

        onFirst: function(e, data, fn, ctx) {
            return this.on(e, data, fn, ctx, {one: true});
        },

        /**
         * Removing event handler(s)
         * @param {String} [e] Event type
         * @param {Function} [fn] Handler
         * @param {Object} [ctx] Handler context
         * @returns {$.observable}
         */
        un: function(e, fn, ctx) {
            if(typeof e == 'string' || typeof e == 'undefined') {
                var storage = this[storageExpando];
                if(storage) {
                    if(e) { // If event type was passed
                        var eList = e.split(' '),
                            i = 0,
                            eStorage;
                        while((e = eList[i++])) {
                            e = this.buildEventName(e);
                            if((eStorage = storage[e])) {
                                if(fn) { // If specific handler was passed
                                    var id = getFnId(fn, ctx),
                                        ids = eStorage.ids;
                                    if(id in ids) {
                                        var list = eStorage.list,
                                            item = ids[id],
                                            prev = item.prev,
                                            next = item.next;

                                        if(prev) {
                                            prev.next = next;
                                        } else if(item === list.first) {
                                            list.first = next;
                                        }

                                        if(next) {
                                            next.prev = prev;
                                        } else if(item === list.last) {
                                            list.last = prev;
                                        }

                                        delete ids[id];
                                    }
                                } else {
                                    delete this[storageExpando][e];
                                }
                            }
                        }
                    } else {
                        delete this[storageExpando];
                    }
                }
            } else {
                var self = this;
                $.each(e, function(e, fn) {
                    self.un(e, fn, ctx);
                });
            }
            return this;
        },

        /**
         * Fires event handlers
         * @param {String|$.Event} e Event
         * @param {Object} [data] Additional data
         * @returns {$.observable}
         */
        trigger: function(e, data) {
            var self = this,
                storage = self[storageExpando],
                rawType;

            typeof e === 'string' ?
                e = $.Event(self.buildEventName(rawType = e)) :
                e.type = self.buildEventName(rawType = e.type);

            e.target || (e.target = self);

            if(storage && (storage = storage[e.type])) {
                var item = storage.list.first,
                    ret;
                while(item) {
                    e.data = item.data;
                    ret = item.fn.call(item.ctx || self, e, data);
                    if(typeof ret !== 'undefined') {
                        e.result = ret;
                        if(ret === false) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }

                    item.special && item.special.one &&
                        self.un(rawType, item.fn, item.ctx);
                    item = item.next;
                }
            }
            return this;
        }
    };

$.observable = $.inherit(Observable, Observable);
})(jQuery);

/* end: ../../../libs/islands/common.blocks/i-jquery/__observable/i-jquery__observable.js */
/* begin: ../../../libs/islands/common.blocks/polyfill/__bind/polyfill__bind.js */
(function() {
var slice = Array.prototype.slice;

Function.prototype.bind || (Function.prototype.bind = function(ctx) {
    var fn = this,
        args = slice.call(arguments, 1);

    return function() {
        return fn.apply(ctx, args.concat(slice.call(arguments)));
    };
});
})();

/* end: ../../../libs/islands/common.blocks/polyfill/__bind/polyfill__bind.js */
/* begin: ../../../libs/islands/common.blocks/i-jquery/__cookie/i-jquery__cookie.js */
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

 /* jshint eqeqeq:false, -W041 */
 /* jscs:disable jsDoc */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie
 *                       (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if(typeof value != 'undefined') { // Name and value given, set cookie
        options = options || {};
        if(value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if(options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if(typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // Use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '',
            domain = options.domain ? '; domain=' + (options.domain) : '',
            secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // Only name given, get cookie
        var cookieValue = null;
        if(document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for(var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if(cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};

/* end: ../../../libs/islands/common.blocks/i-jquery/__cookie/i-jquery__cookie.js */
/* begin: ../../../libs/islands/common.blocks/i-jquery/__decodeuri/i-jquery__decodeuri.js */
/**
 * Plugin for decoding URI-escaped strings in CP1251 encoding
 *
 * Copyright (c) 2011-2012 Roman Rozhdestvenskiy (sbmaxx@gmail.com)
 */
(function($) {
// Equivalency table for cp1251 and utf8.
var map = {
            '%D0': '%D0%A0', '%C0': '%D0%90', '%C1': '%D0%91', '%C2': '%D0%92', '%C3': '%D0%93', '%C4': '%D0%94',
            '%C5': '%D0%95', '%A8': '%D0%81', '%C6': '%D0%96', '%C7': '%D0%97', '%C8': '%D0%98', '%C9': '%D0%99',
            '%CA': '%D0%9A', '%CB': '%D0%9B', '%CC': '%D0%9C', '%CD': '%D0%9D', '%CE': '%D0%9E', '%CF': '%D0%9F',
            '%D1': '%D0%A1', '%D2': '%D0%A2', '%D3': '%D0%A3', '%D4': '%D0%A4', '%D5': '%D0%A5', '%D6': '%D0%A6',
            '%D7': '%D0%A7', '%D8': '%D0%A8', '%D9': '%D0%A9', '%DA': '%D0%AA', '%DB': '%D0%AB', '%DC': '%D0%AC',
            '%DD': '%D0%AD', '%DE': '%D0%AE', '%DF': '%D0%AF', '%E0': '%D0%B0', '%E1': '%D0%B1', '%E2': '%D0%B2',
            '%E3': '%D0%B3', '%E4': '%D0%B4', '%E5': '%D0%B5', '%B8': '%D1%91', '%E6': '%D0%B6', '%E7': '%D0%B7',
            '%E8': '%D0%B8', '%E9': '%D0%B9', '%EA': '%D0%BA', '%EB': '%D0%BB', '%EC': '%D0%BC', '%ED': '%D0%BD',
            '%EE': '%D0%BE', '%EF': '%D0%BF', '%F0': '%D1%80', '%F1': '%D1%81', '%F2': '%D1%82', '%F3': '%D1%83',
            '%F4': '%D1%84', '%F5': '%D1%85', '%F6': '%D1%86', '%F7': '%D1%87', '%F8': '%D1%88', '%F9': '%D1%89',
            '%FA': '%D1%8A', '%FB': '%D1%8B', '%FC': '%D1%8C', '%FD': '%D1%8D', '%FE': '%D1%8E', '%FF': '%D1%8F'
        };

function convert(str) {
    // Symbol code in cp1251 (hex) : symbol code in utf8)
    return str.replace(/%.{2}/g, function($0) { return map[$0] || $0; });
}

function decode(func, str) {
    var decoded = '';
    // Using try/catch block for getting the encoding of the source string
    // Error is thrown if a non-UTF8 string is input
    // If the string was not decoded, it is returned without changes
    try {
        decoded = func(str);
    } catch (e) {
        try {
            decoded = func(convert(str));
        } catch (err) {
            decoded = str;
        }
    }
    return decoded;
}

$.extend({
    decodeURI: function(str) {
        return decode(decodeURI, str);
    },

    decodeURIComponent: function(str) {
        return decode(decodeURIComponent, str);
    }
});
})(jQuery);

/* end: ../../../libs/islands/common.blocks/i-jquery/__decodeuri/i-jquery__decodeuri.js */
/* begin: ../../../libs/islands/common.blocks/i-common/__cookie/i-common__cookie.js */
(function(Lego) {
if(!Lego) {
    Lego = window.Lego = {};
}

Lego.getCookie = function(n) {
    var c = document.cookie;
    if(c.length < 1) {
        return false;
    }

    var b = c.indexOf(n + '=');
    if(b === -1) {
        return false;
    }

    b += (n.length + 1);
    var e = c.indexOf(';', b);

    return decodeURIComponent((e === -1) ? c.substring(b) : c.substring(b, e));
};
})(window.Lego);

/* end: ../../../libs/islands/common.blocks/i-common/__cookie/i-common__cookie.js */
/* begin: ../../../libs/islands/common.blocks/i-common/__check-session/i-common__check-session.js */
(function(Lego) {
if(!Lego) {
    Lego = window.Lego = {};
}
/**
 * Проверяет жива ли сессия пользователя (наличие куки yandex_login).
 *
 * @return {Boolean}
 */
Lego.isSessionValid = function() {
    return Boolean(Lego.getCookie('yandex_login'));
};
})(window.Lego);

/* end: ../../../libs/islands/common.blocks/i-common/__check-session/i-common__check-session.js */
/* begin: ../../../libs/islands/common.blocks/i-jquery/__debounce/i-jquery__debounce.js */
/**
 * Debounce and throttle function's decorator plugin 1.0.6
 *
 * Copyright (c) 2009 Filatov Dmitry (alpha@zforms.ru)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
$.extend({
    debounce: function(fn, timeout, invokeAsap, ctx) {
        var timer;

        if(arguments.length === 3 && typeof invokeAsap !== 'boolean') {
            ctx = invokeAsap;
            invokeAsap = false;
        }

        return function() {
            var args = arguments;
            ctx = ctx || this;

            invokeAsap && !timer && fn.apply(ctx, args);

            clearTimeout(timer);

            timer = setTimeout(function() {
                invokeAsap || fn.apply(ctx, args);
                timer = null;
            }, timeout);
        };
    },

    throttle: function(fn, timeout, ctx) {
        var timer,
            args,
            needInvoke;

        return function() {
            args = arguments;
            needInvoke = true;
            ctx = ctx || this;

            timer || (function() {
                if(needInvoke) {
                    fn.apply(ctx, args);
                    needInvoke = false;
                    /* jshint noarg:false */
                    timer = setTimeout(arguments.callee, timeout);
                } else {
                    timer = null;
                }
            })();
        };
    }
});

/* end: ../../../libs/islands/common.blocks/i-jquery/__debounce/i-jquery__debounce.js */
/* begin: ../../../libs/islands/common.blocks/pointerevents/pointerevents.js */
/* istanbul ignore next: https://st.yandex-team.ru/ISL-1676 */
(function(win, doc, $) {
var CLONE_DICT = {
        // MouseEvent
        bubbles: false,
        cancelable: false,
        view: null,
        detail: null,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: null,

        // DOM Level 3
        buttons: 0,

        // PointerEvent
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tiltX: 0,
        tiltY: 0,
        pointerType: '',
        hwTimestamp: 0,
        isPrimary: false,

        // Event instance
        target: null,
        currentTarget: null,
        which: 0,
        pageX: 0,
        pageY: 0,
        timeStamp: 0
    },
    CLONE_PROPS = Object.keys(CLONE_DICT),
    CLONE_DEFAULTS = CLONE_PROPS.map(function(prop) { return CLONE_DICT[prop] }),
    CLONE_PROPS_LENGTH = CLONE_PROPS.length,
    HAS_BUTTONS = false,
    WHICH_TO_BUTTONS = [0, 1, 4, 2];

try {
    HAS_BUTTONS = new MouseEvent('test', {buttons: 1}).buttons === 1;
} catch (e) {}

// Возвращает нормализованный объект для последующей генерации на его основе pointer событий.
function getPointerProps(event, props) {
    var copy = {},
        orig = event.originalEvent || {};

    props || (props = {});

    for(var i = 0, prop; i < CLONE_PROPS_LENGTH; i++) {
        prop = CLONE_PROPS[i];

        // 1. jQuery нормализует некоторые параметры, поэтому сначала смотрим
        //    в объект события jQuery, потом в оригинальное событие, потом в дефолты.
        // 2. Считаем что CLONE_DEFAULTS содержит единственно возможные falsy значения,
        //    поэтому можно использовать `||` вместо hasOwnProperty.
        copy[prop] = props[prop] || event[prop] || orig[prop] || CLONE_DEFAULTS[i];
    }

    copy.x = copy.clientX;
    copy.y = copy.clientY;

    // Pointers without pressure should have 0.5 for down state and 0 for up state.
    copy.pressure = copy.pressure || (copy.buttons ? 0.5 : 0);

    if(!copy.buttons && !HAS_BUTTONS) {
        copy.buttons = WHICH_TO_BUTTONS[copy.which] || 0;
    }

    // Сохраняем ссылку на оригинальное событие, породившее pointer событие.
    // Оригинального события может и не быть, например в случае $(elem).mousedown().
    copy.originalEvent = event.originalEvent || null;

    if(props.preventDefault) {
        copy.preventDefault = function() {
            props.preventDefault();
            event.preventDefault();
        };

        // LEGO: https://st.yandex-team.ru/ISL-2459
        copy._preventScroll = function() {
            props.preventDefault();
        };
    } else {
        copy.preventDefault = function() {
            event.preventDefault();
        };
        // LEGO: https://st.yandex-team.ru/ISL-2579
        copy._preventScroll = function() {};
    }

    return copy;
}

function getPointerEvent(type, props) {
    var event = $.Event(type),
        propsPreventDefault = props.preventDefault,
        eventPreventDefault = event.preventDefault.bind(event);

    jQuery.extend(event, props);

    event.preventDefault = function() {
        propsPreventDefault();
        eventPreventDefault();
    };

    return event;
}

var USE_NATIVE_MAP = win.Map && win.Map.prototype.forEach,
    pointermap = USE_NATIVE_MAP ? new win.Map() : {
        array: [],
        size: 0,

        set: function(k, v) {
            if(v === undefined) {
                return this['delete'](k);
            }
            if(!this.has(k)) {
                this.size++;
            }
            this.array[k] = v;
        },

        has: function(k) {
            return this.array[k] !== undefined;
        },

        'delete': function(k) {
            if(this.has(k)) {
                delete this.array[k];
                this.size--;
            }
        },

        get: function(k) {
            return this.array[k];
        },

        clear: function() {
            this.array.length = 0;
            this.size = 0;
        },

        // Return value, key, map
        forEach: function(callback, thisArg) {
            return this.array.forEach(function(v, k) {
                callback.call(thisArg, v, k, this);
            }, this);
        }
    },
    dispatcher = {
        eventMap: {},
        captureInfo: {},
        eventSourceList: [],

        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {String} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
            var types = source.events;

            if(types) {
                types.forEach(function(type) {
                    if(source[type]) {
                        this.eventMap[type] = source[type].bind(source);
                    }
                }, this);

                this.eventSourceList.push(source);
            }
        },

        register: function(target) {
            var l = this.eventSourceList.length;
            for(var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
                // Call eventsource register
                es.register.call(es, target);
            }
        },

        unregister: function(target) {
            var l = this.eventSourceList.length;
            for(var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
                // Call eventsource register
                es.unregister.call(es, target);
            }
        },

        contains: function(container, contained) {
            return container.contains(contained);
        },

        getCommonAncestor: function(target, relatedTarget) {
            while(target && target !== doc.documentElement) {
                if(target.contains(relatedTarget)) {
                    return target;
                }
                target = target.parentNode;
            }
            return null;
        },

        down: function(props) {
            props.bubbles = true;
            this.fireEvent('pointerdown', props);
        },

        move: function(props) {
            props.bubbles = true;
            this.fireEvent('pointermove', props);
        },

        up: function(props) {
            props.bubbles = true;
            this.fireEvent('pointerup', props);
        },

        enter: function(props) {
            var stack = [],
                target = props.target,
                commonAncestor = this.getCommonAncestor(target, props.relatedTarget);

            props.bubbles = false;

            while(target && target !== commonAncestor) {
                stack.push(target);
                target = target.parentNode;
            }

            while(stack.length) {
                props.target = stack.pop();
                this.fireEvent('pointerenter', props);
            }
        },

        leave: function(props) {
            var stack = [],
                target = props.target,
                commonAncestor = this.getCommonAncestor(target, props.relatedTarget);

            props.bubbles = false;

            while(target && target !== commonAncestor) {
                stack.push(target);
                target = target.parentNode;
            }

            while(stack.length) {
                props.target = stack.shift();
                this.fireEvent('pointerleave', props);
            }
        },

        over: function(props) {
            props.bubbles = true;
            this.fireEvent('pointerover', props);
        },

        out: function(props) {
            props.bubbles = true;
            this.fireEvent('pointerout', props);
        },

        cancel: function(props) {
            props.bubbles = true;
            this.fireEvent('pointercancel', props);
        },

        leaveOut: function(props) {
            this.out(props);

            // Если это не движение внутрь.
            if(!this.contains(props.target, props.relatedTarget)) {
                this.leave(props);
            }
        },

        enterOver: function(props) {
            this.over(props);
            if(!this.contains(props.target, props.relatedTarget)) {
                this.enter(props);
            }
        },

        // Set up event listeners.
        listen: function(target, types) {
            types.forEach(function(type) {
                this.addEvent(target, type);
            }, this);
        },

        // Remove event listeners.
        unlisten: function(target, types) {
            types.forEach(function(type) {
                this.removeEvent(target, type);
            }, this);
        },

        addEvent: function(target, type) {
            $(target).on(type, this.boundHandler);
        },

        removeEvent: function(target, type) {
            $(target).off(type, this.boundHandler);
        },

        eventHandler: function(jEvent) {
            var cb = this.eventMap[jEvent.type];
            cb && cb(jEvent, jEvent.originalEvent);
        },

        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {String} type A string representing the type of event to create
         * @param {Event} props A platform event with a target
         * @return {Event} A PointerEvent of type `type`
         */
        makeEvent: function(type, props) {
            // RelatedTarget must be null if pointer is captured
            if(this.captureInfo[props.pointerId]) {
                props.relatedTarget = null;
            }

            var event = getPointerEvent(type, props);

            event._target = event._target || props.target;

            return event;
        },

        // Make and dispatch an event in one call
        fireEvent: function(type, props) {
            var event = this.makeEvent(type, props);
            return this.dispatchEvent(event);
        },

        getTarget: function(event) {
            // If pointer capture is set, route all events for the specified pointerId to the capture target.
            return this.captureInfo[event.pointerId] || event._target;
        },

        setCapture: function(pointerId, target) {
            if(this.captureInfo[pointerId]) {
                this.releaseCapture(pointerId);
            }

            this.captureInfo[pointerId] = target;

            this.implicitRelease = this.releaseCapture.bind(this, pointerId);
            $(doc).on('pointerup pointercancel', this.implicitRelease);

            this.asyncDispatchEvent($.Event('gotpointercapture', {
                bubbles: true,
                cancelable: false,
                pointerId: pointerId,
                _target: target
            }));
        },

        releaseCapture: function(pointerId) {
            var target = this.captureInfo[pointerId];

            if(target) {
                this.captureInfo[pointerId] = undefined;

                $(doc).off('pointerup pointercancel', this.implicitRelease);

                this.asyncDispatchEvent($.Event('lostpointercapture', {
                    bubbles: true,
                    cancelable: false,
                    pointerId: pointerId,
                    _target: target
                }));
            }
        },

        /**
         * Dispatches the event to its target.
         *
         * @param {Event} event The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: function(event) {
            var target = this.getTarget(event);
            if(target) {
                return $.event.trigger(event, null, target, !event.bubbles);
            }
        },

        asyncDispatchEvent: function(event) {
            // LEGO: Деградация до setTimeout для IE9-, Android 4.3-.
            (win.requestAnimationFrame || setTimeout)(this.dispatchEvent.bind(this, event));
        }
    };

dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        DEDUP_DIST: 25, // Radius around touchend that swallows mouse events.

        events: [
            'mousedown',
            'mousemove',
            'mouseup',
            'mouseover',
            'mouseout'
        ],

        register: function(target) {
            dispatcher.listen(target, this.events);
        },

        unregister: function(target) {
            dispatcher.unlisten(target, this.events);
        },

        lastTouches: [],

        // Collide with the global mouse listener.
        isEventSimulatedFromTouch: function(event) {
            var lts = this.lastTouches,
                x = event.clientX,
                y = event.clientY;

            for(var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
                // Simulated mouse events will be swallowed near a primary touchend
                var dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if(dx <= this.DEDUP_DIST && dy <= this.DEDUP_DIST) {
                    return true;
                }
            }
        },

        // Возвращает свойства, которые позже используются для создания pointer события.
        prepareEvent: function(event) {
            return getPointerProps(event, {
                pointerId: this.POINTER_ID,
                isPrimary: true,
                pointerType: this.POINTER_TYPE
            });
        },

        mousedown: function(event) {
            if(!this.isEventSimulatedFromTouch(event)) {
                // TODO(dfreedman) workaround for some elements not sending mouseup
                // http://crbug.com/149091
                if(pointermap.has(this.POINTER_ID)) {
                    this.cancel(event);
                }

                pointermap.set(this.POINTER_ID, event);
                dispatcher.down(this.prepareEvent(event));
            }
        },

        mousemove: function(event) {
            if(!this.isEventSimulatedFromTouch(event)) {
                dispatcher.move(this.prepareEvent(event));
            }
        },

        mouseup: function(event) {
            if(!this.isEventSimulatedFromTouch(event)) {
                var p = pointermap.get(this.POINTER_ID);
                if(p && p.button === event.button) {
                    dispatcher.up(this.prepareEvent(event));
                    this.cleanupMouse();
                }
            }
        },

        mouseover: function(event) {
            if(!this.isEventSimulatedFromTouch(event)) {
                dispatcher.enterOver(this.prepareEvent(event));
            }
        },

        mouseout: function(event) {
            if(!this.isEventSimulatedFromTouch(event)) {
                dispatcher.leaveOut(this.prepareEvent(event));
            }
        },

        cancel: function(event) {
            dispatcher.cancel(this.prepareEvent(event));
            this.cleanupMouse();
        },

        cleanupMouse: function() {
            pointermap['delete'](this.POINTER_ID);
        }
    },
    touchEvents = {
        POINTER_TYPE: 'touch',
        DEDUP_TIMEOUT: 2500, // Timeout to ignore compat mouse events made by touch.
        CLICK_COUNT_TIMEOUT: 200,

        events: [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel'
        ],

        register: function(target) {
            dispatcher.listen(target, this.events);
        },

        unregister: function(target) {
            dispatcher.unlisten(target, this.events);
        },

        firstTouch: null,

        isPrimaryTouch: function(touch) {
            return this.firstTouch === touch.identifier;
        },

        setPrimaryTouch: function(touch) {
            // Set primary touch if there no pointers, or the only pointer is the mouse.
            if(pointermap.size === 0 || (pointermap.size === 1 && pointermap.has(1))) {
                this.firstTouch = touch.identifier;
                this.scrolling = false;
                this.shouldScroll = true; // LEGO: По умолчанию скролл разрешен.
                this.cancelResetClickCount();
            }
        },

        removePrimaryPointer: function(props) {
            if(props.isPrimary) {
                this.firstTouch = null;
                this.resetClickCount();
            }
        },

        clickCount: 0,
        resetId: null,

        resetClickCount: function() {
            var fn = function() {
                this.clickCount = 0;
                this.resetId = null;
            }.bind(this);
            this.resetId = setTimeout(fn, this.CLICK_COUNT_TIMEOUT);
        },

        cancelResetClickCount: function() {
            this.resetId && clearTimeout(this.resetId);
        },

        typeToButtons: function(type) {
            return (type === 'touchstart' || type === 'touchmove') ? 1 : 0;
        },

        findTarget: function(touch) {
            // LEGO: Don't interested in shadow DOM handling.
            return doc.elementFromPoint(touch.clientX, touch.clientY);
        },

        touchToPointer: function(touch) {
            var self = this,
                event = this.currentTouchEvent,
                // We reserve pointerId 1 for Mouse.
                // Touch identifiers can start at 0.
                // Add 2 to the touch identifier for compatibility.
                id = touch.identifier + 2;

            return getPointerProps(event, $.extend({}, touch, {
                pointerId: id,
                target: dispatcher.captureInfo[id] || this.findTarget(touch),
                bubbles: true,
                cancelable: true,
                detail: this.clickCount,
                button: 0,
                buttons: this.typeToButtons(event.type),
                width: touch.webkitRadiusX || touch.radiusX || 0,
                height: touch.webkitRadiusY || touch.radiusY || 0,
                pressure: touch.webkitForce || touch.force || 0.5,
                isPrimary: this.isPrimaryTouch(touch),
                pointerType: this.POINTER_TYPE,
                preventDefault: function() {
                    self.scrolling = false;
                    self.shouldScroll = false;
                }
            }));
        },

        processTouches: function(event, cb) {
            var tl = event.originalEvent.changedTouches;

            this.currentTouchEvent = event;

            for(var i = 0, t; i < tl.length; i++) {
                t = tl[i];
                cb.call(this, this.touchToPointer(t));
            }
        },

        findTouch: function(inTL, inId) {
            for(var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
                if(t.identifier === inId) {
                    return true;
                }
            }
        },

        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(event) {
            var touches = event.originalEvent.touches;

            // Property pointermap.size should be < touches.length here, as the touchstart has not
            // been processed yet.
            if(pointermap.size >= touches.length) {
                var d = [];
                pointermap.forEach(function(value, key) {
                    // Never remove pointerId == 1, which is mouse.
                    // Touch identifiers are 2 smaller than their pointerId, which is the
                    // index in pointermap.
                    if(key !== 1 && !this.findTouch(touches, key - 2)) {
                        var p = value.out;
                        d.push(p);
                    }
                }, this);
                d.forEach(this.cancelOut, this);
            }
        },

        touchstart: function(event) {
            var touch = event.originalEvent.changedTouches[0];

            this.vacuumTouches(event);
            this.setPrimaryTouch(touch);
            this.dedupSynthMouse(touch);

            if(!this.scrolling) {
                this.clickCount++;
                this.processTouches(event, this.overDown);
            }
        },

        overDown: function(props) {
            pointermap.set(props.pointerId, {
                target: props.target,
                out: props,
                outTarget: props.target
            });
            dispatcher.over(props);
            dispatcher.enter(props);
            dispatcher.down(props);
        },

        touchmove: function(event) {
            if(!this.scrolling) {
                if(this.shouldScroll) {
                    this.scrolling = true;
                    this.touchcancel(event);
                } else {
                    event.preventDefault();
                    this.processTouches(event, this.moveOverOut);
                }
            }
        },

        moveOverOut: function(props) {
            var pointer = pointermap.get(props.pointerId);

            // A finger drifted off the screen, ignore it.
            if(!pointer) {
                return;
            }

            var outEvent = pointer.out,
                outTarget = pointer.outTarget;

            dispatcher.move(props);

            if(outEvent && outTarget !== props.target) {
                outEvent.relatedTarget = props.target;
                props.relatedTarget = outTarget;

                // Recover from retargeting by shadow
                outEvent.target = outTarget;
                if(props.target) {
                    dispatcher.leaveOut(outEvent);
                    dispatcher.enterOver(props);
                } else {
                    // Clean up case when finger leaves the screen
                    props.target = outTarget;
                    props.relatedTarget = null;
                    this.cancelOut(props);
                }
            }
            pointer.out = props;
            pointer.outTarget = props.target;
        },

        touchend: function(event) {
            this.dedupSynthMouse(event.originalEvent.changedTouches[0]);
            this.processTouches(event, this.upOut);
        },

        upOut: function(props) {
            if(!this.scrolling) {
                dispatcher.up(props);
                dispatcher.out(props);
                dispatcher.leave(props);
            }
            this.cleanUpPointer(props);
        },

        touchcancel: function(event) {
            this.processTouches(event, this.cancelOut);
        },

        cancelOut: function(props) {
            dispatcher.cancel(props);
            dispatcher.out(props);
            dispatcher.leave(props);
            this.cleanUpPointer(props);
        },

        cleanUpPointer: function(props) {
            pointermap['delete'](props.pointerId);
            this.removePrimaryPointer(props);
        },

        // Prevent synth mouse events from creating pointer events.
        dedupSynthMouse: function(touch) {
            var lts = mouseEvents.lastTouches;

            // Only the primary finger will synth mouse events.
            if(this.isPrimaryTouch(touch)) {
                // Remember x/y of last touch
                var lt = {x: touch.clientX, y: touch.clientY};
                lts.push(lt);
                var fn = (function(lts, lt) {
                    var i = lts.indexOf(lt);
                    if(i > -1) {
                        lts.splice(i, 1);
                    }
                }).bind(null, lts, lt);
                setTimeout(fn, this.DEDUP_TIMEOUT);
            }
        }
    },
    msEvents = {
        POINTER_TYPES: [
            '',
            'unavailable',
            'touch',
            'pen',
            'mouse'
        ],
        HAS_BITMAP_TYPE: win.MSPointerEvent && (typeof win.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number'),

        events: [
            'MSPointerDown',
            'MSPointerMove',
            'MSPointerUp',
            'MSPointerOut',
            'MSPointerOver',
            'MSPointerCancel',
            'MSGotPointerCapture',
            'MSLostPointerCapture'
        ],

        register: function(target) {
            dispatcher.listen(target, this.events);
        },

        unregister: function(target) {
            dispatcher.unlisten(target, this.events);
        },

        prepareEvent: function(event) {
            var props = getPointerProps(event);

            if(this.HAS_BITMAP_TYPE) {
                props.pointerType = this.POINTER_TYPES[props.pointerType];
            }

            return props;
        },

        cleanup: function(id) {
            pointermap['delete'](id);
        },

        MSPointerDown: function(event) {
            pointermap.set(event.originalEvent.pointerId, event);
            dispatcher.down(this.prepareEvent(event));
        },

        MSPointerMove: function(event) {
            dispatcher.move(this.prepareEvent(event));
        },

        MSPointerUp: function(event) {
            dispatcher.up(this.prepareEvent(event));
            this.cleanup(event.originalEvent.pointerId);
        },

        MSPointerOut: function(event) {
            dispatcher.leaveOut(this.prepareEvent(event));
        },

        MSPointerOver: function(event) {
            dispatcher.enterOver(this.prepareEvent(event));
        },

        MSPointerCancel: function(event) {
            dispatcher.cancel(this.prepareEvent(event));
            this.cleanup(event.originalEvent.pointerId);
        },

        MSGotPointerCapture: function(event) {
            dispatcher.fireEvent('gotpointercapture', this.prepareEvent(event));
        },

        MSLostPointerCapture: function(event) {
            dispatcher.fireEvent('lostpointercapture', this.prepareEvent(event));
        }
    },
    setPointerCapture,
    releasePointerCapture,
    assertDown = function(pointerId) {
        if(!pointermap.has(pointerId)) {
            throw new Error('InvalidPointerId');
        }
    };

if(win.Element && Element.prototype.setPointerCapture) {
    setPointerCapture = function(elem, pointerId) {
        elem.setPointerCapture(pointerId);
    };
    releasePointerCapture = function(elem, pointerId) {
        elem.releasePointerCapture(pointerId);
    };
} else if(win.navigator.msPointerEnabled) {
    setPointerCapture = function(elem, pointerId) {
        assertDown(pointerId);
        elem.msSetPointerCapture(pointerId);
    };
    releasePointerCapture = function(elem, pointerId) {
        assertDown(pointerId);
        elem.msReleasePointerCapture(pointerId);
    };
} else {
    setPointerCapture = function(elem, pointerId) {
        assertDown(pointerId);
        dispatcher.setCapture(pointerId, elem);
    };
    releasePointerCapture = function(elem, pointerId) {
        assertDown(pointerId);
        dispatcher.releaseCapture(pointerId, elem);
    };
}

$.fn.extend({
    setPointerCapture: function(pointerId) {
        setPointerCapture(this[0], pointerId);
    },

    releasePointerCapture: function(pointerId) {
        releasePointerCapture(this[0], pointerId);
    }
});

if(win._pointerPolyfillInited) {
    /* jshint ignore:line *//* jscs:ignore */(/*%%%ISLDEBUG%%%*/+0 && console.error('pointerevents: pointerevents уже инициализирован.'));
    return;
}

win._pointerPolyfillInited = true;

if(!win.PointerEvent) {
    // В jquery подписка на события pointerenter/pointerleave
    // организована через подписку на pointerover/pointerout.
    // Так как мы сами генерируем все эти события, нужно удалить
    // фиксы в jquery, чтобы избежать двойного срабатывания pointerenter/pointerleave.
    delete $.event.special.pointerenter;
    delete $.event.special.pointerleave;

    if(win.navigator.msPointerEnabled) {
        dispatcher.registerSource('ms', msEvents);
    } else {
        dispatcher.registerSource('mouse', mouseEvents);
        if(win.ontouchstart !== undefined) {
            dispatcher.registerSource('touch', touchEvents);
        }
    }

    dispatcher.register(document);
} else {
    ['move', 'down', 'up', 'over', 'out', 'enter', 'leave', 'cancel'].forEach(function(name) {
        var fixHooks = jQuery.event.fixHooks,
            eventName = 'pointer' + name;

        fixHooks[eventName] || (fixHooks[eventName] = {});
        fixHooks[eventName].props = CLONE_PROPS.concat(fixHooks[eventName].props || []);
    });
}
})(window, document, jQuery);

/* end: ../../../libs/islands/common.blocks/pointerevents/pointerevents.js */
/* begin: ../../../libs/islands/common.blocks/pointerevents/__click/pointerevents__click.js */
/* istanbul ignore next: https://st.yandex-team.ru/ISL-1676 */

// 1. В Chrome 50 под iOS не происходит touchcancel при открытии контекстного меню по долгому тапу.
//    При этом после закрытия меню (открыть ссылку в фоне или нажать отмену), при нажатии в любое
//    место страницы, браузер заодно кидает touchend у элемента для которого открывалось меню.
//    Чтобы такой сценарий не распознавался как pointerclick, используется таймаут между pointerdown/up.
//    Подробнее: https://st.yandex-team.ru/ISL-2560

(function(win, $) {
if($.event.special.pointerclick) {
    /* jshint ignore:line *//* jscs:ignore */(/*%%%ISLDEBUG%%%*/+0 && console.error('pointerevents__click: Событие pointerclick уже установлено.'));
    return;
}

var TOUCH_ABLE = (win.ontouchstart !== undefined) || (navigator.msMaxTouchPoints > 0), // https://clck.ru/9b7Pd
    CLICK_DIST = 10, // Радиус, в пределах которого pointerdown → pointerup генерируют pointerclick.
    DEDUP_DIST = 25, // Радиус, в пределах которого считать click синтетическим.
    DEDUP_TIME = 2500, // Таймаут, в пределах которого ожидаем возникновение синтетического события.
    PRESS_TIME = 250, // Таймаут, в пределах которого ждем pointerup.
    lastPoints = [], // Координаты и цели pointer-событий, произошедших накануне.
    timeoutId = null,
    dEvent = null,
    handlers;

if(!TOUCH_ABLE) {
    handlers = {
        click: function(e) {
            return dispatch.apply(this, arguments);
        }
    };
} else {
    handlers = {
        // 1. Программные клики, к пр. elem.click()
        // 2. Клики по связанным элементам через <label>
        // 3. Клавиатурные нажатия ENTER/SPACE
        // 4. Устройства с комбинированным вводом
        // 5. PhantomJS (https://github.com/ariya/phantomjs/issues/10375)
        click: function(e) {
            if(!isSimulated(e)) {
                return dispatch.apply(this, arguments);
            }
        },

        'pointerdown pointermove pointerleave pointercancel pointerup': function(e) {
            var t = e.type;

            if(e.pointerType === 'mouse') {
                return;
            } else if(t === 'pointerdown') {
                dedupEvent(e);
                dEvent = e;
            } else if(t === 'pointermove' && dEvent && (dEvent.target !== e.target || isOutOfClickDist(dEvent, e))) {
                dEvent = null;
            } else if(t === 'pointerleave' || t === 'pointercancel') {
                dEvent = null;
            } else if(t === 'pointerup') {
                dedupEvent(e);

                if(!dEvent) {
                    return;
                }

                if(e.timeStamp - dEvent.timeStamp > PRESS_TIME) { // 1.
                    dEvent = null;
                } else {
                    timeoutId || (timeoutId = setTimeout(function() {
                        // Флаг скидывается асинхронно, после того, как все обработчики отработают,
                        // иначе pointerclick сработает только у первого элемента в цепочке.
                        timeoutId = dEvent = null;
                    }));

                    return dispatch.apply(this, arguments);
                }
            }
        }
    };

    // Защита от «проваливания» кликов: https://st.yandex-team.ru/ISL-2246
    // Синтетических событий гораздо больше, мы предотвращаем только самые проблемные.
    ['mousedown', 'click'].forEach(function(type) {
        win.addEventListener(type, function(e) {
            if(isSimulated(e, true)) {
                e.preventDefault(); // Иначе произойдет переход по ссылке, не смотря на stopPropagation.
                e.stopPropagation();
            }
        }, true);
    });
}

function dedupEvent(e) {
    // Только основной pointer может вызывать синтетические события.
    if(e.isPrimary) {
        // Сохраняем не только координаты, но и target. Актуально для кликов по <label>.
        // Когда браузер генерирует клик на соответствующем htmlFor элементе,
        // он меняет target, но оставляет старые координаты.
        lastPoints.push({x: e.clientX, y: e.clientY, target: e.target});
        setTimeout(Array.prototype.shift.bind(lastPoints), DEDUP_TIME);
    }
}

function isOutOfClickDist(e1, e2) {
    return (Math.abs(e1.clientX - e2.clientX) > CLICK_DIST) || (Math.abs(e1.clientY - e2.clientY) > CLICK_DIST);
}

function isSimulated(e, movedOnly) {
    var x = e.clientX,
        y = e.clientY;

    return lastPoints.some(function(p) {
        // Координаты синтетического клика всегда должны быть примерно те же.
        if((Math.abs(x - p.x) > DEDUP_DIST) || (Math.abs(y - p.y) > DEDUP_DIST)) {
            return false;
        }

        var isTargetWhereItWas = document.elementFromPoint(p.x, p.y) === p.target;

        // Цели должны совпадать, если по этим координатам не появился другой элемент.
        if(p.target !== e.target && isTargetWhereItWas) {
            return false;
        }

        return movedOnly ? !isTargetWhereItWas : true;
    });
}

function dispatch(e) {
    var origType = e.type,
        result;

    // 1. Свойство e.button может отсутствовать, если кто-то неаккуратно сгенерировал событие.
    //    Например вызвал $(elem).click(). Такое встречается в тестах.
    // 2. Если e.button есть, то нас интересует только левая кнопка (0).
    if(!e.button) {
        e.type = 'pointerclick';
        result = $.event.dispatch.apply(this, arguments);
        e.type = origType;
    }

    return result;
}

$.event.special.pointerclick = {
    setup: function() {
        $(this).on(handlers);
    },

    teardown: function() {
        $(this).off(handlers);
    }
};
})(window, jQuery);

/* end: ../../../libs/islands/common.blocks/pointerevents/__click/pointerevents__click.js */
/* begin: ../../../libs/islands/common.blocks/pointerevents/__pressrelease/pointerevents__pressrelease.js */
/* istanbul ignore next: https://st.yandex-team.ru/ISL-1676 */
(function($) {
    if($.event.special.pointerpress) {
        /* jshint ignore:line *//* jscs:ignore */(/*%%%ISLDEBUG%%%*/+0 && console.error('pointerevents__press: Событие pointerpress уже установлено.'));
        return;
    }

    $.each({
        pointerpress: 'pointerdown',
        pointerrelease: 'pointerup pointercancel'
    }, function(alias, type) {
        function handler(e) {
            var type = e.type,
                result;

            // У мыши реагируем только на левую кнопку, т.к.
            // правая вызывает контекстное меню, а центральная
            // включает режим прокрутки страницы в IE.
            if((e.pointerType !== 'mouse') || (e.which === 1)) {
                e.type = alias;
                result = $.event.dispatch.apply(this, arguments);
                e.type = type;
            }

            return result;
        }

        $.event.special[alias] = {
            setup: function() {
                $(this).on(type, handler);
            },
            teardown: function() {
                $(this).off(type, handler);
            }
        };
    });
})(jQuery);

/* end: ../../../libs/islands/common.blocks/pointerevents/__pressrelease/pointerevents__pressrelease.js */
/* begin: ../../../libs/islands/common.blocks/i-jquery/__dom/i-jquery__dom.js */
(function($) {
    $.dom = {
        /**
         * Возвращает ссылку на активный (document.activeElement) DOM-элемент.
         * Как правило, это элемент, находящийся в фокусе.
         *
         * @returns {jQuery}
         */
        getActiveElement: function() {
            // "Unspecified error" in iframe in IE9.
            try {
                return $(document.activeElement);
            } catch(e) {
                return $();
            }
        }
    };

    /**
     * Проверяет, что activeElement ссылается на текущий элемент.
     *
     * @returns {Boolean}
     */
    $.fn.isFocused = function() {
        return this.is($.dom.getActiveElement());
    };
})(jQuery);

/* end: ../../../libs/islands/common.blocks/i-jquery/__dom/i-jquery__dom.js */
/* begin: ../../../libs/islands/common.blocks/pointerfocus/pointerfocus.js */
/**
 * Занимательные факты, обнаруженные в процессе работы над блоком.
 *
 * 1. Обычно, фокус выставляется браузером сразу после mousedown/touchstart.
 *
 * 2. В FF Mac и Safari большинство контролов не получают фокус по событиям мыши
 *    и не позволяют сделать это программно в обработчике mousedown.
 *    При этом в обработчике mouseup выставить программный фокус можно.
 *    Подробности: http://jsfiddle.net/mishaberezin/892yppts/2/.
 *
 * 3. HTMLLabelElement после клика на себе производит синтетический клик по
 *    связанному элементу, после чего на связанном элементе происходит focus.
 *    При этом ни mousedown ни mouseup не происходят.
 *
 * 4. FF не поддерживает focusin, зато умеет всплытие у события focus.
 *    Остальные браузеры умеют и focus и focusin, но вот в IE событие
 *    focus ведет себя ненадежно. Например, при перемещении стрелками
 *    по радиогруппе, события на элементе наступают в такой последовательности:
 *    keydown → focusin → click (синтетический) → focus.
 *    В jQuery событие focusin нормализовано и ведет себя достаточно надежно.
 *    Подробности:
 *    * https://bugzilla.mozilla.org/687787
 *    * http://jsfiddle.net/mishaberezin/8gz4ryhy/10/
 *
 * 5. Фокус у контролов с атрибутом autofocus выставляется в момент разбора
 *    до DOMContentLoaded.
 *
 * 6. В IE8 `setTimeout instanceof Function // false`.
 *    Соответственно метод bind у setTimeout не работает даже с полифиллом.
 *
 * 7. На iOS и Android < 5 событие focusin срабатывает гораздо позднее, чем просто в следующем тике
 *    (~ через 300-400ms) после нажатия. Кроме этого, программную установку фокуса иногда заворачивают в
 *    afterCurrentEvent. Чтобы корректно обрабатывать такие случаи, мы сбрасываем флаг isPointer c запасом
 *    через 600ms, а не в следующем тике.
 *
 * 8. Выставляем isPointer, чтобы, когда пользователь вернется
 *    на вкладку, pointerfocus не переключился в utilityfocus.
 *    Подробнее: https://st.yandex-team.ru/ISL-1973
 *
 * 9. В IE≤9 при переключении вкладок события focus и blur (sic) на window происходят
 *    позже, чем focusin на documentElement. Из-за этого приходится использовать
 *    focusin на documentElement с проверкой fromElement (IE8) и relatedTarget (IE9).
 *    Подробнее: http://stackoverflow.com/q/13575216/
 *
 * 10. В Opera12 событие focus на window наступает при перемещении фокуса между элементами
 *     с помощью клавиатуры. Поэтому подписываемся на первое событие focus после blur.
 */
(function() {
var $win = $(window),
    $doc = $(document.documentElement),
    timeoutId = 0,
    isPointer = false;

function setIsPointerOnTabFocus() { // 8
    if(!$doc.hasClass('pointerfocus')) { return; }
    isPointer = true;
    setTimeout(function() {
        isPointer = false;
    });
}

if(document.documentMode <= 9) { // 9
    $doc.on('focusin', function(e) {
        var o = e.originalEvent;
        if(o && !o.fromElement && !o.relatedTarget) {
            setIsPointerOnTabFocus();
        }
    });
} else {
    $win.on('blur', function() { // 10
        $win.one('focus', setIsPointerOnTabFocus);
    });
}

$doc.addClass('utilityfocus') // 5
    .on({
        focusin: function() { // 4
            $doc.toggleClass('pointerfocus', isPointer)
                .toggleClass('utilityfocus', !isPointer);
        },
        keydown: function() {
            // Если не выставить isPointer=false по keydown и если фокус вызван нажатием на Tab в течение 600ms
            // после клика, то utilityfocus не будет установлен.
            clearTimeout(timeoutId);
            isPointer = false;
        },
        'pointerdown pointerup click': function(e) { // 1,2,3
            isPointer = true;
            clearTimeout(timeoutId);
            timeoutId = setTimeout(function() { // 6
                 isPointer = false;
            }, 600); // 7
        }
    });
})();

/* end: ../../../libs/islands/common.blocks/pointerfocus/pointerfocus.js */
/* begin: ../../../libs/islands/common.blocks/util/util.js */
$.extend({
    util: {}
});

/* end: ../../../libs/islands/common.blocks/util/util.js */
/* begin: ../../../libs/islands/common.blocks/i-bem/i-bem.js */
/* jshint eqeqeq: false, maxparams: false */
/** @requires jquery.inherit */
/** @requires jquery.identify */
/** @requires jquery.observable */

(function($, undefined) {
/**
 * Storage for deferred functions
 * @private
 * @type {Array}
 */
var afterCurrentEventFns = [],

/**
 * Storage for block declarations (hash by block name)
 * @private
 * @type {Object}
 */
    blocks = {},

/**
 * Communication channels
 * @static
 * @private
 * @type {Object}
 */
    channels = {};

/**
 * Builds the name of the handler method for setting a modifier
 * @static
 * @private
 * @param {String} elemName Element name
 * @param {String} modName Modifier name
 * @param {String} modVal Modifier value
 * @returns {String}
 */
function buildModFnName(elemName, modName, modVal) {
    return (elemName ? '__elem_' + elemName : '') +
           '__mod' +
           (modName ? '_' + modName : '') +
           (modVal ? '_' + modVal : '');
}

/**
 * Transforms a hash of modifier handlers to methods
 * @static
 * @private
 * @param {Object} modFns
 * @param {Object} props
 * @param {String} [elemName]
 */
function modFnsToProps(modFns, props, elemName) {
    $.isFunction(modFns) ?
        (props[buildModFnName(elemName, '*', '*')] = modFns) :
        $.each(modFns, function(modName, modFn) {
            $.isFunction(modFn) ?
                (props[buildModFnName(elemName, modName, '*')] = modFn) :
                $.each(modFn, function(modVal, modFn) {
                    props[buildModFnName(elemName, modName, modVal)] = modFn;
                });
        });
}

function buildCheckMod(modName, modVal) {
    return modVal ?
        Array.isArray(modVal) ?
            function(block) {
                var i = 0, len = modVal.length;
                while(i < len) {
                    if(block.hasMod(modName, modVal[i++])) {
                        return true;
                    }
                }
                return false;
            } :
            function(block) {
                return block.hasMod(modName, modVal);
            } :
        function(block) {
            return block.hasMod(modName);
        };
}

/**
 * @desc Base block for creating BEM blocks
 * @class BEM
 */
this.BEM = $.inherit($.observable, /** @lends BEM.prototype */ {
    /**
     * @constructs
     * @private
     * @param {Object} mods Block modifiers
     * @param {Object} params Block parameters
     * @param {Boolean} [initImmediately=true]
     */
    __constructor: function(mods, params, initImmediately) {
        var _this = this;

        /**
         * Cache of block modifiers
         * @private
         * @type Object
         */
        _this._modCache = mods || {};

        /**
         * Current modifiers in the stack
         * @private
         * @type Object
         */
        _this._processingMods = {};

        /**
         * The block's parameters, taking into account the defaults
         * @protected
         * @type Object
         */
        _this._params = params; // Для правильной сборки параметров у блока из нескольких DOM-элементов
        _this.params = null;

        initImmediately !== false ?
            _this._init() :
            _this.afterCurrentEvent(function() {
                _this._init();
            });
    },

    /**
     * Initializes the block
     * @private
     * @returns {BEM}
     */
    _init: function() {
        if(!this._initing && !this.hasMod('js', 'inited')) {
            this._initing = true;

            if(!this.params) {
                this.params = $.extend(this.getDefaultParams(), this._params);
                delete this._params;
            }

            this.setMod('js', 'inited');
            delete this._initing;
            this.hasMod('js', 'inited') && this.trigger('init');
        }

        return this;
    },

    /**
     * Changes the context of the function being passed
     * @protected
     * @param {Function} fn
     * @param {Object} [ctx=this] Context
     * @returns {Function} Function with a modified context
     */
    changeThis: function(fn, ctx) {
        return fn.bind(ctx || this);
    },

    /**
     * Executes the function in the context of the block, after the "current event"
     * @protected
     * @param {Function} fn
     * @param {Object} [ctx] Context
     */
    afterCurrentEvent: function(fn, ctx) {
        this.__self.afterCurrentEvent(this.changeThis(fn, ctx));
    },

    /**
     * Executes the block's event handlers and live event handlers
     * @protected
     * @param {String} e Event name
     * @param {Object} [data] Additional information
     * @returns {BEM}
     */
    trigger: function(e, data) {
        this
            .__base(e = this.buildEvent(e), data)
            .__self.trigger(e, data);

        return this;
    },

    buildEvent: function(e) {
        typeof e == 'string' && (e = $.Event(e));
        e.block = this;

        return e;
    },

    /**
     * Checks whether a block or nested element has a modifier
     * @protected
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {Boolean}
     */
    hasMod: function(elem, modName, modVal) {
        var len = arguments.length,
            invert = false;

        if(len == 1) {
            modVal = '';
            modName = elem;
            elem = undefined;
            invert = true;
        } else if(len == 2) {
            if(typeof elem == 'string') {
                modVal = modName;
                modName = elem;
                elem = undefined;
            } else {
                modVal = '';
                invert = true;
            }
        }

        var res = this.getMod(elem, modName) === modVal;
        return invert ? !res : res;
    },

    /**
     * Returns the value of the modifier of the block/nested element
     * @protected
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @returns {String} Modifier value
     */
    getMod: function(elem, modName) {
        var type = typeof elem;
        if(type === 'string' || type === 'undefined') { // Elem either omitted or undefined
            modName = elem || modName;
            var modCache = this._modCache;
            return modName in modCache ?
                modCache[modName] :
                modCache[modName] = this._extractModVal(modName);
        }

        return this._getElemMod(modName, elem);
    },

    /**
     * Returns the value of the modifier of the nested element
     * @private
     * @param {String} modName Modifier name
     * @param {Object} elem Nested element
     * @param {Object} [elemName] Nested element name
     * @returns {String} Modifier value
     */
    _getElemMod: function(modName, elem, elemName) {
        return this._extractModVal(modName, elem, elemName);
    },

    /**
     * Returns values of modifiers of the block/nested element
     * @protected
     * @param {Object} [elem] Nested element
     * @param {...String} [modName] Modifier names
     * @returns {Object} Hash of modifier values
     */
    getMods: function(elem) {
        var hasElem = elem && typeof elem != 'string',
            _this = this,
            modNames = [].slice.call(arguments, hasElem ? 1 : 0),
            res = _this._extractMods(modNames, hasElem ? elem : undefined);

        if(!hasElem) { // Caching
            modNames.length ?
                modNames.forEach(function(name) {
                    _this._modCache[name] = res[name];
                }) :
                _this._modCache = res;
        }

        return res;
    },

    /**
     * Sets the modifier for a block/nested element
     * @protected
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @returns {BEM}
     */
    setMod: function(elem, modName, modVal) {
        if(typeof modVal == 'undefined') {
            modVal = modName;
            modName = elem;
            elem = undefined;
        }

        var _this = this;

        if(!elem || elem[0]) {
            var modId = (elem && elem[0] ? $.identify(elem[0]) : '') + '_' + modName;

            if(this._processingMods[modId]) {
                return _this;
            }

            var elemName,
                curModVal = elem ?
                    _this._getElemMod(modName, elem, elemName = _this.__self._extractElemNameFrom(elem)) :
                    _this.getMod(modName);

            if(curModVal === modVal) {
                return _this;
            }

            this._processingMods[modId] = true;

            var needSetMod = true,
                modFnParams = [modName, modVal, curModVal];

            elem && modFnParams.unshift(elem);

            [['*', '*'], [modName, '*'], [modName, modVal]].forEach(function(mod) {
                needSetMod = _this._callModFn(elemName, mod[0], mod[1], modFnParams) !== false && needSetMod;
            });

            !elem && needSetMod && (_this._modCache[modName] = modVal);

            needSetMod && _this._afterSetMod(modName, modVal, curModVal, elem, elemName);

            delete this._processingMods[modId];
        }

        return _this;
    },

    /**
     * Function after successfully changing the modifier of the block/nested element
     * @protected
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @param {String} oldModVal Old modifier value
     * @param {Object} [elem] Nested element
     * @param {String} [elemName] Element name
     */
    _afterSetMod: function(modName, modVal, oldModVal, elem, elemName) {},

    /**
     * Sets a modifier for a block/nested element, depending on conditions.
     * If the condition parameter is passed: when true, modVal1 is set; when false, modVal2 is set.
     * If the condition parameter is not passed: modVal1 is set if modVal2 was set, or vice versa.
     * @protected
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} modVal1 First modifier value
     * @param {String} [modVal2] Second modifier value
     * @param {Boolean} [condition] Condition
     * @returns {BEM}
     */
    toggleMod: function(elem, modName, modVal1, modVal2, condition) {
        if(typeof elem == 'string') { // If this is a block
            condition = modVal2;
            modVal2 = modVal1;
            modVal1 = modName;
            modName = elem;
            elem = undefined;
        }
        if(typeof modVal2 == 'undefined') {
            modVal2 = '';
        } else if(typeof modVal2 == 'boolean') {
            condition = modVal2;
            modVal2 = '';
        }

        var modVal = this.getMod(elem, modName);
        (modVal == modVal1 || modVal == modVal2) &&
            this.setMod(
                elem,
                modName,
                typeof condition === 'boolean' ?
                    (condition ? modVal1 : modVal2) :
                    this.hasMod(elem, modName, modVal1) ? modVal2 : modVal1);

        return this;
    },

    /**
     * Removes a modifier from a block/nested element
     * @protected
     * @param {Object} [elem] Nested element
     * @param {String} modName Modifier name
     * @returns {BEM}
     */
    delMod: function(elem, modName) {
        if(!modName) {
            modName = elem;
            elem = undefined;
        }

        return this.setMod(elem, modName, '');
    },

    /**
     * Executes handlers for setting modifiers
     * @private
     * @param {String} elemName Element name
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @param {Array} modFnParams Handler parameters
     * @returns {*|undefined}
     */
    _callModFn: function(elemName, modName, modVal, modFnParams) {
        var modFnName = buildModFnName(elemName, modName, modVal);
        return this[modFnName] ?
           this[modFnName].apply(this, modFnParams) :
           undefined;
    },

    /**
     * Retrieves the value of the modifier
     * @private
     * @param {String} modName Modifier name
     * @param {Object} [elem] Element
     * @returns {String} Modifier value
     */
    _extractModVal: function(modName, elem) {
        return '';
    },

    /**
     * Retrieves name/value for a list of modifiers
     * @private
     * @param {Array} modNames Names of modifiers
     * @param {Object} [elem] Element
     * @returns {Object} Hash of modifier values by name
     */
    _extractMods: function(modNames, elem) {
        return {};
    },

    /**
     * Returns a named communication channel
     * @param {String} [id='default'] Channel ID
     * @param {Boolean} [drop=false] Destroy the channel
     * @returns {$.observable|undefined} Communication channel
     */
    channel: function(id, drop) {
        return this.__self.channel(id, drop);
    },

    /**
     * Returns a block's default parameters
     * @returns {Object}
     */
    getDefaultParams: function() {
        return {};
    },

    /**
     * Helper for cleaning up block properties
     * @param {Object} [obj=this]
     * @returns {BEM}
     */
    del: function(obj) {
        var args = [].slice.call(arguments);
        typeof obj == 'string' && args.unshift(this);
        this.__self.del.apply(this.__self, args);
        return this;
    },

    /**
     * Deletes a block
     */
    destruct: function() {}

}, $.extend(this.BEM, /** @lends BEM */ {

    _name: 'i-bem',

    /**
     * Storage for block declarations (hash by block name)
     * @static
     * @protected
     * @type Object
     */
    blocks: blocks,

    /**
     * Declares blocks and creates a block class
     * @static
     * @protected
     * @param {String|Object} decl Block name (simple syntax) or description
     * @param {String} decl.block|decl.name Block name
     * @param {String} [decl.baseBlock] Name of the parent block
     * @param {String} [decl.modName] Modifier name
     * @param {String} [decl.modVal] Modifier value
     * @param {Object} [props] Methods
     * @param {Object} [staticProps] Static methods
     * @returns {Function}
     */
    decl: function(decl, props, staticProps) {
        if(typeof decl == 'string') {
            decl = {block: decl};
        } else if(decl.name) {
            decl.block = decl.name;
        }

        if(decl.baseBlock && !blocks[decl.baseBlock]) {
            throw('baseBlock "' + decl.baseBlock + '" for "' + decl.block + '" is undefined');
        }

        props || (props = {});

        if(props.onSetMod) {
            modFnsToProps(props.onSetMod, props);
            delete props.onSetMod;
        }

        if(props.onElemSetMod) {
            $.each(props.onElemSetMod, function(elemName, modFns) {
                modFnsToProps(modFns, props, elemName);
            });
            delete props.onElemSetMod;
        }

        var baseBlock = blocks[decl.baseBlock || decl.block] || this;

        if(decl.modName) {
            var checkMod = buildCheckMod(decl.modName, decl.modVal);
            $.each(props, function(name, prop) {
                $.isFunction(prop) &&
                    (props[name] = function() {
                        var method;
                        if(checkMod(this)) {
                            method = prop;
                        } else {
                            var baseMethod = baseBlock.prototype[name];
                            baseMethod && baseMethod !== props[name] &&
                                (method = this.__base);
                        }
                        return method ?
                            method.apply(this, arguments) :
                            undefined;
                    });
            });
        }

        if(staticProps && typeof staticProps.live === 'boolean') {
            var live = staticProps.live;
            staticProps.live = function() {
                return live;
            };
        }

        var block;
        if(decl.block == baseBlock._name) {
            // Makes a new "live" if the old one was already executed
            (block = $.inheritSelf(baseBlock, props, staticProps))._processLive(true);
        } else {
            (block = blocks[decl.block] = $.inherit(baseBlock, props, staticProps))._name = decl.block;
            delete block._liveInitable;
        }

        return block;
    },

    /**
     * Processes block's live properties.
     * @private
     * @param {Boolean} [heedLive=false] Take into account that block has already processed its live properties.
     * @returns {Boolean} Whether the block is a live block.
     */
    _processLive: function(heedLive) {
        return false;
    },

    /**
     * Factory method for creating an instance of the block named
     * @static
     * @param {String|Object} block Block name or description
     * @param {Object} [params] Block parameters
     * @returns {Object} Instance
     */
    create: function(block, params) {
        typeof block == 'string' && (block = {block: block});

        return new blocks[block.block](block.mods, params);
    },

    /**
     * Returns the name of the current block
     * @static
     * @protected
     * @returns {String}
     */
    getName: function() {
        return this._name;
    },

    /**
     * Retrieves the name of an element nested in a block
     * @static
     * @private
     * @abstract
     * @param {Object} elem Nested element
     */
    _extractElemNameFrom: function(elem) {},

    /**
     * Adds a function to the queue for executing after the "current event"
     * @static
     * @protected
     * @param {Function} fn
     * @param {Object} ctx
     */
    afterCurrentEvent: function(fn, ctx) {
        afterCurrentEventFns.push({fn: fn, ctx: ctx}) == 1 &&
            setTimeout(this._runAfterCurrentEventFns, 0);
    },

    /**
     * Executes the queue
     * @protected
     */
    _runAfterCurrentEventFns: function() {
        var fnsLen = afterCurrentEventFns.length;

        fnsLen && afterCurrentEventFns.splice(0, fnsLen).forEach(function(fnObj) {
            fnObj.fn.call(fnObj.ctx || this);
        }, this);
    },

    /**
     * Changes the context of the function being passed
     * @protected
     * @param {Function} fn
     * @param {Object} ctx Context
     * @returns {Function} Function with a modified context
     */
    changeThis: function(fn, ctx) {
        return fn.bind(ctx || this);
    },

    /**
     * Helper for cleaning out properties
     * @param {Object} [obj=this]
     * @returns {BEM}
     */
    del: function(obj) {
        var delInThis = typeof obj == 'string',
            i = delInThis ? 0 : 1,
            len = arguments.length;
        delInThis && (obj = this);

        while(i < len) {
            delete obj[arguments[i++]];
        }

        return this;
    },

    /**
     * Returns/destroys a named communication channel
     * @param {String} [id='default'] Channel ID
     * @param {Boolean} [drop=false] Destroy the channel
     * @returns {$.observable|undefined} Communication channel
     */
    channel: function(id, drop) {
        if(typeof id == 'boolean') {
            drop = id;
            id = undefined;
        }

        id || (id = 'default');

        if(drop) {
            if(channels[id]) {
                channels[id].un();
                delete channels[id];
            }
            return;
        }

        return channels[id] || (channels[id] = new $.observable());
    }

}));
})(jQuery);

/* end: ../../../libs/islands/common.blocks/i-bem/i-bem.js */
/* begin: ../../../libs/islands/common.blocks/i-bem/__internal/i-bem__internal.js */
/* jshint eqeqeq: false, maxparams: false */
/**
 * @file Module for internal BEM helpers
 * @requires BEM
 */

(function(BEM, $, undefined) {
/**
 * Separator for modifiers and their values
 * @const
 * @type String
 */
var MOD_DELIM = '_',

/**
 * Separator between names of a block and a nested element
 * @const
 * @type String
 */
    ELEM_DELIM = '__',

/**
 * Pattern for acceptable element and modifier names
 * @const
 * @type String
 */
    NAME_PATTERN = '[a-zA-Z0-9-]+';

function buildModPostfix(modName, modVal, buffer) {
    buffer.push(MOD_DELIM, modName, MOD_DELIM, modVal);
}

function buildBlockClass(name, modName, modVal, buffer) {
    buffer.push(name);
    modVal && buildModPostfix(modName, modVal, buffer);
}

function buildElemClass(block, name, modName, modVal, buffer) {
    buildBlockClass(block, undefined, undefined, buffer);
    buffer.push(ELEM_DELIM, name);
    modVal && buildModPostfix(modName, modVal, buffer);
}

BEM.INTERNAL = {

    NAME_PATTERN: NAME_PATTERN,

    MOD_DELIM: MOD_DELIM,
    ELEM_DELIM: ELEM_DELIM,

    buildModPostfix: function(modName, modVal, buffer) {
        var res = buffer || [];
        buildModPostfix(modName, modVal, res);
        return buffer ? res : res.join('');
    },

    /**
     * Builds the class of a block or element with a modifier
     * @private
     * @param {String} block Block name
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @param {Array} [buffer] Buffer
     * @returns {String|Array} Class or buffer string (depending on whether the buffer parameter is present)
     */
    buildClass: function(block, elem, modName, modVal, buffer) {
        var typeOf = typeof modName;
        if(typeOf == 'string') {
            if(typeof modVal != 'string' && typeof modVal != 'number') {
                buffer = modVal;
                modVal = modName;
                modName = elem;
                elem = undefined;
            }
        } else if(typeOf != 'undefined') {
            buffer = modName;
            modName = undefined;
        } else if(elem && typeof elem != 'string') {
            buffer = elem;
            elem = undefined;
        }

        if(!(elem || modName || buffer)) { // Оптимизация для самого простого случая
            return block;
        }

        var res = buffer || [];

        elem ?
            buildElemClass(block, elem, modName, modVal, res) :
            buildBlockClass(block, modName, modVal, res);

        return buffer ? res : res.join('');
    },

    /**
     * Builds full classes for a buffer or element with modifiers
     * @private
     * @param {String} block Block name
     * @param {String} [elem] Element name
     * @param {Object} [mods] Modifiers
     * @param {Array} [buffer] Buffer
     * @returns {String|Array} Class or buffer string (depending on whether the buffer parameter is present)
     */
    buildClasses: function(block, elem, mods, buffer) {
        if(elem && typeof elem != 'string') {
            buffer = mods;
            mods = elem;
            elem = undefined;
        }

        var res = buffer || [];

        elem ?
            buildElemClass(block, elem, undefined, undefined, res) :
            buildBlockClass(block, undefined, undefined, res);

        mods && $.each(mods, function(modName, modVal) {
            if(modVal) {
                res.push(' ');
                elem ?
                    buildElemClass(block, elem, modName, modVal, res) :
                    buildBlockClass(block, modName, modVal, res);
            }
        });

        return buffer ? res : res.join('');
    }
};
})(BEM, jQuery);

/* end: ../../../libs/islands/common.blocks/i-bem/__internal/i-bem__internal.js */
/* begin: ../../../libs/islands/common.blocks/i-bem/__dom/i-bem__dom.js */
/* jshint eqeqeq: false, maxparams: false, maxdepth: 6, loopfunc:true */
/**
 * @requires BEM
 * @requires BEM.INTERNAL
 */

(function(BEM, $, undefined) {
var win = $(window),
    doc = $(document),

/**
 * Storage for DOM elements by unique key
 * @private
 * @type {Object}
 */
    uniqIdToDomElems = {},

/**
 * Storage for blocks by unique key
 * @static
 * @private
 * @type {Object}
 */
    uniqIdToBlock = {},

/**
 * Storage for block parameters
 * @private
 * @type {Object}
 */
    domElemToParams = {},

/**
 * Storage for liveCtx event handlers
 * @private
 * @type {Object}
 */
    liveEventCtxStorage = {},

/**
 * Storage for liveClass event handlers
 * @private
 * @type {Object}
 */
    liveClassEventStorage = {},

    blocks = BEM.blocks,

    INTERNAL = BEM.INTERNAL,

    NAME_PATTERN = INTERNAL.NAME_PATTERN,

    MOD_DELIM = INTERNAL.MOD_DELIM,
    ELEM_DELIM = INTERNAL.ELEM_DELIM,

    buildModPostfix = INTERNAL.buildModPostfix,
    buildClass = INTERNAL.buildClass,

    slice = Array.prototype.slice,
    reverse = Array.prototype.reverse;

/**
 * Initializes blocks on a DOM element
 * @private
 * @param {jQuery} domElem DOM element
 * @param {String} uniqInitId ID of the "initialization wave"
 */
function init(domElem, uniqInitId) {
    var domNode = domElem[0];
    $.each(getParams(domNode), function(blockName, params) {
        processParams(params, domNode, blockName, uniqInitId);
        var block = uniqIdToBlock[params.uniqId];
        if(block) {
            if(block.domElem.index(domNode) < 0) {
                block.domElem = block.domElem.add(domElem);
                $.extend(block._params, params);
            }
        } else {
            initBlock(blockName, domElem, params);
        }
    });
}

/**
 * Initializes a specific block on a DOM element, or returns the existing block if it was already created
 * @private
 * @param {String} blockName Block name
 * @param {jQuery} domElem DOM element
 * @param {Object} [params] Initialization parameters
 * @param {Boolean} [forceLive] Force live initialization
 * @param {Function} [callback] Handler to call after complete initialization
 * @returns {BEM.DOM}
 */
function initBlock(blockName, domElem, params, forceLive, callback) {
    if(typeof params == 'boolean') {
        callback = forceLive;
        forceLive = params;
        params = undefined;
    }

    var domNode = domElem[0];
    params = processParams(params || getParams(domNode)[blockName], domNode, blockName);

    var uniqId = params.uniqId;
    if(uniqIdToBlock[uniqId]) {
        return uniqIdToBlock[uniqId]._init();
    }

    uniqIdToDomElems[uniqId] = uniqIdToDomElems[uniqId] ?
        uniqIdToDomElems[uniqId].add(domElem) :
        domElem;

    var parentDomNode = domNode.parentNode;
    if(!parentDomNode || parentDomNode.nodeType === 11) { // JQuery doesn't unique disconnected node
        $.unique(uniqIdToDomElems[uniqId]);
    }

    var BlockClass = blocks[blockName] || DOM.decl(blockName, {}, {live: true});
    if(!(BlockClass._liveInitable = Boolean(BlockClass._processLive())) || forceLive || params.live === false) {
        forceLive && domElem.addClass('i-bem');

        var block = new BlockClass(uniqIdToDomElems[uniqId], params, Boolean(forceLive));

        delete uniqIdToDomElems[uniqId];
        callback && callback.apply(block, slice.call(arguments, 4));
        return block;
    }
}

/**
 * Processes and adds necessary block parameters
 * @private
 * @param {Object} params Initialization parameters
 * @param {HTMLElement} domNode DOM node
 * @param {String} blockName Block name
 * @param {String} [uniqInitId] ID of the "initialization wave"
 * @returns {Object}
 */
function processParams(params, domNode, blockName, uniqInitId) {
    (params || (params = {})).uniqId ||
        (params.uniqId = (params.id ? blockName + '-id-' + params.id : $.identify()) + (uniqInitId || $.identify()));

    var domUniqId = $.identify(domNode),
        domParams = domElemToParams[domUniqId] || (domElemToParams[domUniqId] = {});

    domParams[blockName] || (domParams[blockName] = params);

    return params;
}

/**
 * Helper for searching for a DOM element using a selector inside the context, including the context itself
 * @private
 * @param {jQuery} ctx Context
 * @param {String} selector CSS selector
 * @param {Boolean} [excludeSelf=false] Exclude context from search
 * @returns {jQuery}
 */
function findDomElem(ctx, selector, excludeSelf) {
    var res = ctx.find(selector);
    return excludeSelf ?
       res :
       res.add(ctx.filter(selector));
}

/**
 * Returns parameters of a block's DOM element
 * @private
 * @param {HTMLElement} domNode DOM node
 * @returns {Object}
 */
function getParams(domNode) {
    var uniqId = $.identify(domNode);
    return domElemToParams[uniqId] ||
           (domElemToParams[uniqId] = extractParams(domNode));
}

/**
 * Retrieves block parameters from a DOM element
 * @private
 * @param {HTMLElement} domNode DOM node
 * @returns {Object}
 */
function extractParams(domNode) {
    var fn,
        elem,
        attr = domNode.getAttribute('data-bem');

    if(attr) {
        return JSON.parse(attr);
    }

    fn = domNode.onclick || domNode.ondblclick;

    // LEGO-2027 in FF onclick doesn't work on body
    if(!fn && domNode.tagName.toLowerCase() == 'body') {
        elem = $(domNode);
        attr = elem.attr('onclick') || elem.attr('ondblclick');
        /*jshint -W054 */
        attr && (fn = new Function(attr));
        /*jshint +W054 */
    }

    return fn ? fn() : {};
}

/**
 * Cleans up all the BEM storages associated with a DOM node
 * @private
 * @param {HTMLElement} domNode DOM node
 */
function cleanupDomNode(domNode) {
    delete domElemToParams[$.identify(domNode)];
}

/**
 * Uncople DOM node from the block. If this is the last node, then destroys the block.
 * @private
 * @param {BEM.DOM} block block
 * @param {HTMLElement} domNode DOM node
 */
function removeDomNodeFromBlock(block, domNode) {
    block.domElem.length === 1 ?
        block.destruct(true) :
        block.domElem = block.domElem.not(domNode);
}

/**
 * Returns a block on a DOM element and initializes it if necessary
 * @param {String} blockName Block name
 * @param {Object} params Block parameters
 * @returns {BEM.DOM}
 */
$.fn.bem = function(blockName, params) {
    return initBlock(blockName, this, params, true);
};

/**
 * Provides methods for work with DOM tree
 *
 * @desc Base block for creating BEM blocks that have DOM representation
 * @class BEM.DOM
 * @extends BEM
 * @block i-bem
 * @mod default
 */
var DOM = BEM.DOM = BEM.decl('i-bem__dom', {
    /**
     * @constructs
     * @private
     * @param {jQuery} domElem DOM element that the block is created on
     * @param {Object} params Block parameters
     * @param {Boolean} [initImmediately=true]
     */
    __constructor: function(domElem, params, initImmediately) {
        var _this = this;

        /**
         * Block's DOM elements
         * @protected
         * @type jQuery
         */
        _this.domElem = domElem;

        /**
         * Cache for names of events on DOM elements
         * @private
         * @type Object
         */
        _this._eventNameCache = {};

        /**
         * Cache for elements
         * @private
         * @type Object
         */
        _this._elemCache = {};

        /**
         * Unique block ID
         * @private
         * @type String
         */
        uniqIdToBlock[_this._uniqId = params.uniqId || $.identify(_this)] = _this;

        /**
         * Flag for whether it's necessary to unbind from the document and window when destroying the block
         * @private
         * @type Boolean
         */
        _this._needSpecialUnbind = false;

        _this.__base(null, params, initImmediately);
    },

    /**
     * Finds blocks inside the current block or its elements (including context)
     * @protected
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEM.DOM[]}
     */
    findBlocksInside: function(elem, block) {
        return this._findBlocks('find', elem, block);
    },

    /**
     * Finds the first block inside the current block or its elements (including context)
     * @protected
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEM.DOM}
     */
    findBlockInside: function(elem, block) {
        return this._findBlocks('find', elem, block, true);
    },

    /**
     * Finds blocks outside the current block or its elements (including context)
     * @protected
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEM.DOM[]}
     */
    findBlocksOutside: function(elem, block) {
        return this._findBlocks('parents', elem, block);
    },

    /**
     * Finds the first block outside the current block or its elements (including context)
     * @protected
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEM.DOM}
     */
    findBlockOutside: function(elem, block) {
        return this._findBlocks('closest', elem, block)[0] || null;
    },

    /**
     * Finds blocks on DOM elements of the current block or its elements
     * @protected
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEM.DOM[]}
     */
    findBlocksOn: function(elem, block) {
        return this._findBlocks('', elem, block);
    },

    /**
     * Finds the first block on DOM elements of the current block or its elements
     * @protected
     * @param {String|jQuery} [elem] Block element
     * @param {String|Object} block Name or description (block,modName,modVal) of the block to find
     * @returns {BEM.DOM}
     */
    findBlockOn: function(elem, block) {
        return this._findBlocks('', elem, block, true);
    },

    _findBlocks: function(select, elem, block, onlyFirst) {
        if(!this.domElem) {
            return [];
        }

        if(!block) {
            block = elem;
            elem = undefined;
        }

        var ctxElem = elem ?
                (typeof elem == 'string' ? this.findElem(elem) : elem) :
                this.domElem,
            isSimpleBlock = typeof block == 'string',
            blockName = isSimpleBlock ? block : (block.block || block.blockName),
            selector = '.' +
                (isSimpleBlock ?
                    buildClass(blockName) :
                    buildClass(blockName, block.modName, block.modVal)) +
                (onlyFirst ? ':first' : ''),
            domElems = ctxElem.filter(selector);

        select && (domElems = domElems.add(ctxElem[select](selector)));

        if(onlyFirst) {
            return domElems[0] ? initBlock(blockName, domElems.eq(0), true) : null;
        }

        var res = [],
            uniqIds = {};

        $.each(domElems, function(i, domElem) {
            var block = initBlock(blockName, $(domElem), true);
            if(!uniqIds[block._uniqId]) {
                uniqIds[block._uniqId] = true;
                res.push(block);
            }
        });

        return res;
    },

    /**
     * Adds an event handler for any DOM element
     * @protected
     * @param {jQuery} domElem DOM element where the event will be listened for
     * @param {String|Object} event Event name or event object
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {BEM.DOM}
     */
    bindToDomElem: function(domElem, event, fn) {
        var _this = this;

        fn ?
            domElem.bind(
                _this._buildEventName(event),
                function(e) {
                    (e.data || (e.data = {})).domElem = $(this);
                    return fn.apply(_this, arguments);
                }
            ) :
            $.each(event, function(event, fn) {
                _this.bindToDomElem(domElem, event, fn);
            });

        return _this;
    },

    /**
     * Adds an event handler to the document
     * @protected
     * @param {String} event Event name
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {BEM.DOM}
     */
    bindToDoc: function(event, fn) {
        this._needSpecialUnbind = true;
        return this.bindToDomElem(doc, event, fn);
    },

    /**
     * Adds an event handler to the window
     * @protected
     * @param {String} event Event name
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {BEM.DOM}
     */
    bindToWin: function(event, fn) {
        var _fn = fn,
            currentHeight,
            currentWidth;

        if(event === 'resize') {
            fn = function() {
                var height = win.height(),
                    width = win.width();

                if(currentHeight !== height || currentWidth !== width) {
                    currentHeight = height;
                    currentWidth = width;

                    _fn.apply(this, arguments);
                }
            };
        }

        this._needSpecialUnbind = true;

        return this.bindToDomElem(win, event, fn);
    },

    /**
     * Adds an event handler to the block's main DOM elements or its nested elements
     * @protected
     * @param {jQuery|String} [elem] Element
     * @param {String} event Event name
     * @param {Function} fn Handler function, which will be executed in the block's context
     * @returns {BEM.DOM}
     */
    bindTo: function(elem, event, fn) {
        if(!event || $.isFunction(event)) { // If there is no element
            fn = event;
            event = elem;
            elem = this.domElem;
        } else if(typeof elem == 'string') {
            elem = this.elem(elem);
        }

        return this.bindToDomElem(elem, event, fn);
    },

    /**
     * Removes event handlers from any DOM element
     * @protected
     * @param {jQuery} domElem DOM element where the event was being listened for
     * @param {String} event Event name
     * @returns {BEM.DOM}
     */
    unbindFromDomElem: function(domElem, event) {
        domElem.unbind(this._buildEventName(event));
        return this;
    },

    /**
     * Removes event handler from document
     * @protected
     * @param {String} event Event name
     * @returns {BEM.DOM}
     */
    unbindFromDoc: function(event) {
        return this.unbindFromDomElem(doc, event);
    },

    /**
     * Removes event handler from window
     * @protected
     * @param {String} event Event name
     * @returns {BEM.DOM}
     */
    unbindFromWin: function(event) {
        return this.unbindFromDomElem(win, event);
    },

    /**
     * Removes event handlers from the block's main DOM elements or its nested elements
     * @protected
     * @param {jQuery|String} [elem] Nested element
     * @param {String} event Event name
     * @returns {BEM.DOM}
     */
    unbindFrom: function(elem, event) {
        if(!event) {
            event = elem;
            elem = this.domElem;
        } else if(typeof elem == 'string') {
            elem = this.elem(elem);
        }

        return this.unbindFromDomElem(elem, event);
    },

    /**
     * Builds a full name for an event
     * @private
     * @param {String} event Event name
     * @returns {String}
     */
    _buildEventName: function(event) {
        var _this = this;
        return event.indexOf(' ') > 1 ?
            event.split(' ').map(function(e) {
                return _this._buildOneEventName(e);
            }).join(' ') :
            _this._buildOneEventName(event);
    },

    /**
     * Builds a full name for a single event
     * @private
     * @param {String} event Event name
     * @returns {String}
     */
    _buildOneEventName: function(event) {
        var eventNameCache = this._eventNameCache;

        if(event in eventNameCache) {
            return eventNameCache[event];
        }

        var uniq = '.' + this._uniqId;

        if(event.indexOf('.') === -1) {
            eventNameCache[event] = event + uniq;
            return eventNameCache[event];
        }

        var lego = '.bem_' + this.__self._name;

        eventNameCache[event] = event.split('.').map(function(e, i) {
            return i === 0 ? e + lego : lego + '_' + e;
        }).join('') + uniq;

        return eventNameCache[event];
    },

    /**
     * Triggers block event handlers and live event handlers
     * @protected
     * @param {String} e Event name
     * @param {Object} [data] Additional information
     * @returns {BEM.DOM}
     */
    trigger: function(e, data) {
        this
            .__base(e = this.buildEvent(e), data)
            .domElem && this._ctxTrigger(e, data);

        return this;
    },

    _ctxTrigger: function(e, data) {
        var _this = this,
            storage = liveEventCtxStorage[_this.__self._buildCtxEventName(e.type)],
            ctxIds = {};

        storage && _this.domElem.each(function() {
            var ctx = this,
                counter = storage.counter;
            while(ctx && counter) {
                var ctxId = $.identify(ctx, true);
                if(ctxId) {
                    if(ctxIds[ctxId]) {
                        break;
                    }
                    var storageCtx = storage.ctxs[ctxId];
                    if(storageCtx) {
                        $.each(storageCtx, function(uniqId, handler) {
                            handler.fn.call(
                                handler.ctx || _this,
                                e,
                                data);
                        });
                        counter--;
                    }
                    ctxIds[ctxId] = true;
                }
                ctx = ctx.parentNode;
            }
        });
    },

    /**
     * Sets a modifier for a block/nested element
     * @protected
     * @param {jQuery} [elem] Nested element
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @returns {BEM.DOM}
     */
    setMod: function(elem, modName, modVal) {
        if(elem && typeof modVal != 'undefined' && elem.length > 1) {
            var _this = this;
            elem.each(function() {
                var item = $(this);
                item.__bemElemName = elem.__bemElemName;
                _this.setMod(item, modName, modVal);
            });
            return _this;
        }

        return this.__base(elem, modName, modVal);
    },

    /**
     * Retrieves modifier value from the DOM node's CSS class
     * @private
     * @param {String} modName Modifier name
     * @param {jQuery} [elem] Nested element
     * @param {String} [elemName] Name of the nested element
     * @returns {String} Modifier value
     */
    _extractModVal: function(modName, elem, elemName) {
        var domNode = (elem || this.domElem)[0],
            matches;

        domNode &&
            (matches = domNode.className
                .match(this.__self._buildModValRE(modName, elemName || elem)));

        return matches ? matches[2] : '';
    },

    /**
     * Retrieves a name/value list of modifiers
     * @private
     * @param {Array} [modNames] Names of modifiers
     * @param {Object} [elem] Element
     * @returns {Object} Hash of modifier values by names
     */
    _extractMods: function(modNames, elem) {
        var res = {},
            extractAll = !modNames.length,
            countMatched = 0;

        ((elem || this.domElem)[0].className
            .match(this.__self._buildModValRE(
                '(' + (extractAll ? NAME_PATTERN : modNames.join('|')) + ')',
                elem,
                'g')) || []).forEach(function(className) {
                    var iModVal = (className = className.trim()).lastIndexOf(MOD_DELIM),
                        iModName = className.substr(0, iModVal - 1).lastIndexOf(MOD_DELIM);
                    res[className.substr(iModName + 1, iModVal - iModName - 1)] = className.substr(iModVal + 1);
                    ++countMatched;
                });

        // Empty modifier values are not reflected in classes; they must be filled with empty values
        countMatched < modNames.length && modNames.forEach(function(modName) {
            modName in res || (res[modName] = '');
        });

        return res;
    },

    /**
     * Sets a modifier's CSS class for a block's DOM element or nested element
     * @private
     * @param {String} modName Modifier name
     * @param {String} modVal Modifier value
     * @param {String} oldModVal Old modifier value
     * @param {jQuery} [elem] Element
     * @param {String} [elemName] Element name
     */
    _afterSetMod: function(modName, modVal, oldModVal, elem, elemName) {
        if(this._isDestructing) {
            return;
        }

        var _self = this.__self,
            classPrefix = _self._buildModClassPrefix(modName, elemName),
            classRE = _self._buildModValRE(modName, elemName),
            needDel = modVal === '';

        (elem || this.domElem).each(function() {
            var className = this.className;
            className.indexOf(classPrefix) > -1 ?
                this.className = className.replace(
                    classRE,
                    (needDel ? '' : '$1' + classPrefix + modVal)) :
                needDel || $(this).addClass(classPrefix + modVal);
        });

        elemName && this
            .dropElemCache(elemName, modName, oldModVal)
            .dropElemCache(elemName, modName, modVal);
    },

    /**
     * Finds elements nested in a block
     * @protected
     * @param {String|jQuery} [ctx=this.domElem] Element where search is being performed
     * @param {String} names Nested element name (or names separated by spaces)
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {jQuery} DOM elements
     */
    findElem: function(ctx, names, modName, modVal) {
        if(arguments.length % 2) { // If the number of arguments is one or three
            modVal = modName;
            modName = names;
            names = ctx;
            ctx = this.domElem;
        } else if(typeof ctx == 'string') {
            ctx = this.findElem(ctx);
        }

        names = names.split(' ');

        var blockName = this.__self.getName(),
            modPostfix = buildModPostfix(modName, modVal),
            selectors = [],
            keys = names.map(function(name) {
                selectors.push('.' + buildClass(blockName, name, modName, modVal));
                return name + modPostfix;
            }),
            isSingleName = keys.length === 1,
            res = findDomElem(ctx, selectors.join(','));

        // Caching results if possible
        (ctx === this.domElem) &&
            selectors.forEach(function(selector, i) {
                (this._elemCache[keys[i]] = isSingleName ? res : res.filter(selector))
                    .__bemElemName = names[i];
            }, this);

        return res;
    },

    /**
     * Finds elements nested in a block
     * @protected
     * @param {String} name Nested element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {jQuery} DOM elements
     */
    _elem: function(name, modName, modVal) {
        return this._elemCache[name + buildModPostfix(modName, modVal)] ||
            this.findElem(name, modName, modVal);
    },

    /**
     * Lazy search for elements nested in a block (caches results)
     * @protected
     * @param {String} names Nested element name (or names separated by spaces)
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {jQuery} DOM elements
     */
    elem: function(names, modName, modVal) {
        if(modName && typeof modName != 'string') {
            modName.__bemElemName = names;
            return modName;
        }

        if(names.indexOf(' ') < 0) {
            return this._elem(names, modName, modVal);
        }

        var res = $([]);

        names.split(' ').forEach(function(name) {
            res = res.add(this._elem(name, modName, modVal));
        }, this);

        return res;
    },

    /**
     * Clearing the cache for elements
     * @protected
     * @param {String} [names] Nested element name (or names separated by spaces)
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {BEM.DOM}
     */
    dropElemCache: function(names, modName, modVal) {
        if(names) {
            var modPostfix = buildModPostfix(modName, modVal);
            names.indexOf(' ') < 0
                ? delete this._elemCache[names + modPostfix]
                : names.split(' ').forEach(function(name) {
                    delete this._elemCache[name + modPostfix];
                }, this);
        } else {
            this._elemCache = {};
        }

        return this;
    },

    /**
     * Retrieves parameters of a block element
     * @param {String|jQuery} elem Element
     * @returns {Object} Parameters
     */
    elemParams: function(elem) {
        var elemName;
        if(typeof elem == 'string') {
            elemName = elem;
            elem = this.elem(elem);
        } else {
            elemName = this.__self._extractElemNameFrom(elem);
        }

        return extractParams(elem[0])[buildClass(this.__self.getName(), elemName)] || {};
    },

    /**
     * Elemify given element
     * @param {jQuery} elem Element
     * @param {String} elemName Name
     * @returns {jQuery}
     */
    elemify: function(elem, elemName) {
        (elem = $(elem)).__bemElemName = elemName;
        return elem;
    },

    /**
     * Checks whether a DOM element is in a block
     * @protected
     * @param {jQuery} domElem DOM element
     * @returns {Boolean}
     */
    containsDomElem: function(domElem) {
        var res = false;

        this.domElem.each(function() {
            return !(res = domElem.parents().andSelf().index(this) > -1);
        });

        return res;
    },

    /**
     * Builds a CSS selector corresponding to a block/element and modifier
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {String}
     */
    buildSelector: function(elem, modName, modVal) {
        return this.__self.buildSelector(elem, modName, modVal);
    },

    /**
     * Deletes a block
     * @param {Boolean} [keepDOM=false] Whether to keep the block's DOM nodes in the document
     */
    destruct: function(keepDOM) {
        var _this = this,
            _self = _this.__self;

        if(_this._isDestructing) {
            return;
        }

        _this._isDestructing = true;

        _this._needSpecialUnbind && _self.doc.add(_self.win).unbind('.' + _this._uniqId);

        _this.dropElemCache().domElem.each(function(i, domNode) {
            var params = getParams(domNode);
            $.each(params, function(blockName, blockParams) {
                var block = uniqIdToBlock[blockParams.uniqId];
                block ?
                    block._isDestructing || removeDomNodeFromBlock(block, domNode) :
                    delete uniqIdToDomElems[blockParams.uniqId];
            });
            cleanupDomNode(domNode);
        });

        keepDOM || _this.domElem.remove();

        delete uniqIdToBlock[_this.un()._uniqId];
        delete _this.domElem;
        delete _this._elemCache;

        _this.__base();
    }
}, {

    /**
     * Scope
     * Will be set on onDomReady to tag `body`
     * @type {jQuery}
     */
    scope: null,

    /**
     * Document shortcut
     * @type {jQuery}
     */
    doc: doc,

    /**
     * Window shortcut
     * @type {jQuery}
     */
    win: win,

    /**
     * Processes a block's live properties
     * @private
     * @param {Boolean} [heedLive=false] Take into account that block has already processed its live properties
     * @returns {Boolean} Whether block is a live block
     */
    _processLive: function(heedLive) {
        var res = this._liveInitable;

        if('live' in this) {
            var noLive = typeof res == 'undefined';

            if(noLive ^ heedLive) {
                res = this.live() !== false;

                var blockName = this.getName(),
                    origLive = this.live;

                this.live = function() {
                    return (this.getName() === blockName) ? res : origLive.apply(this, arguments);
                };
            }
        }

        return res;
    },

    /**
     * Initializes blocks on a fragment of the DOM tree
     * @param {String|jQuery} [ctx=document] Root DOM node or HTML-string
     * @param {Function} callback Called after initialize
     * @param {Object} callbackCtx Collback context
     * @returns {jQuery} ctx Initialization context
     */
    init: function(ctx, callback, callbackCtx) {
        if(!ctx || $.isFunction(ctx)) {
            callbackCtx = callback;
            callback = ctx;
            ctx = doc;
        } else if(typeof ctx === 'string') {
            ctx = $(ctx);
        }

        var uniqInitId = $.identify();
        findDomElem(ctx, '.i-bem').each(function() {
            init($(this), uniqInitId);
        });

        callback && this.afterCurrentEvent(
            function() {
                callback.call(callbackCtx || this, ctx);
            });

        // Makes initialization completely synchronous
        this._runAfterCurrentEventFns();

        return ctx;
    },

    /**
     * Destroys blocks on a fragment of the DOM tree
     * @param {Boolean} [keepDOM=false] Whether to keep DOM nodes in the document
     * @param {jQuery} ctx Root DOM node
     * @param {Boolean} [excludeSelf=false] Exclude the context
     */
    destruct: function(keepDOM, ctx, excludeSelf) {
        if(typeof keepDOM != 'boolean') {
            excludeSelf = ctx;
            ctx = keepDOM;
            keepDOM = undefined;
        }

        reverse.call(findDomElem(ctx, '.i-bem', excludeSelf)).each(function(i, domNode) {
            var params = getParams(this);
            $.each(params, function(blockName, blockParams) {
                if(blockParams.uniqId) {
                    var block = uniqIdToBlock[blockParams.uniqId];
                    block ?
                        removeDomNodeFromBlock(block, domNode) :
                        delete uniqIdToDomElems[blockParams.uniqId];
                }
            });
            cleanupDomNode(this);
        });
        keepDOM || (excludeSelf ? ctx.empty() : ctx.remove());
    },

    /**
     * Replaces a fragment of the DOM tree inside the context, destroying old blocks and intializing new ones
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content New content
     * @param {Function} [callback] Handler to be called after initialization
     * @param {Object} [callbackCtx] Handler's context
     * @returns {jQuery} ctx Initialization context
     */
    update: function(ctx, content, callback, callbackCtx) {
        this.destruct(ctx, true);
        return this.init(ctx.html(content), callback, callbackCtx);
    },

    /**
     * Changes a fragment of the DOM tree including the context and initializes blocks.
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} ctx Initialization context
     */
    replace: function(ctx, content) {
        this.destruct(true, ctx);
        return this.init($(content).replaceAll(ctx));
    },

    /**
     * Adds a fragment of the DOM tree at the end of the context and initializes blocks
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} ctx Initialization context
     */
    append: function(ctx, content) {
        return this.init($(content).appendTo(ctx));
    },

    /**
     * Adds a fragment of the DOM tree at the beginning of the context and initializes blocks
     * @param {jQuery} ctx Root DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} ctx Initialization context
     */
    prepend: function(ctx, content) {
        return this.init($(content).prependTo(ctx));
    },

    /**
     * Adds a fragment of the DOM tree before the context and initializes blocks
     * @param {jQuery} ctx Contextual DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} ctx Initialization context
     */
    before: function(ctx, content) {
        return this.init($(content).insertBefore(ctx));
    },

    /**
     * Adds a fragment of the DOM tree after the context and initializes blocks
     * @param {jQuery} ctx Contextual DOM node
     * @param {jQuery|String} content Content to be added
     * @returns {jQuery} ctx Initialization context
     */
    after: function(ctx, content) {
        return this.init($(content).insertAfter(ctx));
    },

    /**
     * Builds a full name for a live event
     * @static
     * @private
     * @param {String} e Event name
     * @returns {String}
     */
    _buildCtxEventName: function(e) {
        return this._name + ':' + e;
    },

    _liveClassBind: function(className, e, callback, invokeOnInit) {
        var _this = this;
        if(e.indexOf(' ') > -1) {
            e.split(' ').forEach(function(e) {
                _this._liveClassBind(className, e, callback, invokeOnInit);
            });
        } else {
            var storage = liveClassEventStorage[e],
                uniqId = $.identify(callback);

            if(!storage) {
                storage = liveClassEventStorage[e] = {};
                doc.bind(e, _this.changeThis(_this._liveClassTrigger, _this));
            }

            storage = storage[className] || (storage[className] = {uniqIds: {}, fns: []});

            if(!(uniqId in storage.uniqIds)) {
                storage.fns.push({uniqId: uniqId, fn: _this._buildLiveEventFn(callback, invokeOnInit)});
                storage.uniqIds[uniqId] = storage.fns.length - 1;
            }
        }

        return this;
    },

    _liveClassUnbind: function(className, e, callback) {
        var storage = liveClassEventStorage[e];

        if(storage) {
            if(callback) {
                if((storage = storage[className])) {
                    var uniqId = $.identify(callback);
                    if(uniqId in storage.uniqIds) {
                        var i = storage.uniqIds[uniqId],
                            len = storage.fns.length - 1;
                        storage.fns.splice(i, 1);
                        while(i < len) {
                            storage.uniqIds[storage.fns[i++].uniqId] = i - 1;
                        }
                        delete storage.uniqIds[uniqId];
                    }
                }
            } else {
                delete storage[className];
            }
        }

        return this;
    },

    _liveClassTrigger: function(e) {
        var storage = liveClassEventStorage[e.type];

        if(!storage) {
            return;
        }

        var node = e.target,
            classNames = Object.keys(storage);

        do {
            var nodeClassName = ' ' + node.className + ' ',
                className,
                i = 0;

            while((className = classNames[i++])) {
                if(nodeClassName.indexOf(' ' + className + ' ') === -1) {
                    continue;
                }

                var stopPropagationAndPreventDefault = false;

                storage[className].fns.forEach(function(fn) {
                    if(fn.fn.call($(node), e) === false) {
                        stopPropagationAndPreventDefault = true;
                    }
                });

                stopPropagationAndPreventDefault && e.preventDefault();

                if(stopPropagationAndPreventDefault || e.isPropagationStopped()) {
                    return;
                }

                classNames.splice(--i, 1);
            }
        } while(classNames.length && (node = node.parentNode));
    },

    _buildLiveEventFn: function(callback, invokeOnInit) {
        var _this = this;
        return function(e) {
            var args = [
                    _this._name,
                    ((e.data || (e.data = {})).domElem = $(this)).closest(_this.buildSelector()),
                    true],
                block = initBlock.apply(null, invokeOnInit ? args.concat([callback, e]) : args);

            if(block && !invokeOnInit && callback) {
                return callback.apply(block, arguments);
            }
        };
    },

    /**
     * Helper for live initialization for an event on DOM elements of a block or its elements
     * @static
     * @protected
     * @param {String} [elemName] Element name or names (separated by spaces)
     * @param {String} event Event name
     * @param {Function} [callback] Handler to call after successful initialization
     * @returns {BEM.DOM}
     */
    liveInitOnEvent: function(elemName, event, callback) {
        return this.liveBindTo(elemName, event, callback, true);
    },

    /**
     * Helper for subscribing to live events on DOM elements of a block or its elements
     * @static
     * @protected
     * @param {String|Object} [to] Object (with modName, modVal, elem) or space-separated names of the elements.
     * @param {String} event Event name
     * @param {Function} [callback] Handler
     * @returns {BEM.DOM}
     */
    liveBindTo: function(to, event, callback, invokeOnInit) {
        if(!event || $.isFunction(event)) {
            callback = event;
            event = to;
            to = undefined;
        }

        if(!to || typeof to == 'string') {
            to = {elem: to};
        }

        to.elemName && (to.elem = to.elemName);

        var _this = this;

        if(to.elem && to.elem.indexOf(' ') > 0) {
            to.elem.split(' ').forEach(function(elem) {
                _this._liveClassBind(
                    buildClass(_this._name, elem, to.modName, to.modVal),
                    event,
                    callback,
                    invokeOnInit);
            });
            return _this;
        }

        return _this._liveClassBind(
            buildClass(_this._name, to.elem, to.modName, to.modVal),
            event,
            callback,
            invokeOnInit);
    },

    /**
     * Helper for unsubscribing from live events on DOM elements of a block or its elements
     * @static
     * @protected
     * @param {String} [elem] Name of the element or elements (space-separated)
     * @param {String} event Event name
     * @param {Function} [callback] Handler
     * @returns {BEM.DOM}
     */
    liveUnbindFrom: function(elem, event, callback) {
        if(!event || $.isFunction(event)) {
            callback = event;
            event = elem;
            elem = undefined;
        }

        var _this = this;

        if(elem && elem.indexOf(' ') > 1) {
            elem.split(' ').forEach(function(elem) {
                _this._liveClassUnbind(
                    buildClass(_this._name, elem),
                    event,
                    callback);
            });
            return _this;
        }

        return _this._liveClassUnbind(
            buildClass(_this._name, elem),
            event,
            callback);
    },

    /**
     * Helper for live initialization when a different block is initialized
     * @static
     * @private
     * @param {String} event Event name
     * @param {String} blockName Name of the block that should trigger a reaction when initialized
     * @param {Function} callback Handler to be called after successful initialization in the new block's context
     * @param {String} findFnName Name of the method for searching
     * @returns {BEM.DOM}
     */
    _liveInitOnBlockEvent: function(event, blockName, callback, findFnName) {
        var name = this._name;
        blocks[blockName].on(event, function(e) {
            // If block was destructed at that moment.
            if(!e.block.domElem) {
                return;
            }

            var args = arguments,
                blocks = e.block[findFnName](name);

            callback && blocks.forEach(function(block) {
                callback.apply(block, args);
            });
        });
        return this;
    },

    /**
     * Helper for live initialization for a different block's event on the current block's DOM element
     * @static
     * @protected
     * @param {String} event Event name
     * @param {String} blockName Name of the block that should trigger a reaction when initialized
     * @param {Function} callback Handler to be called after successful initialization in the new block's context
     * @returns {BEM.DOM}
     */
    liveInitOnBlockEvent: function(event, blockName, callback) {
        return this._liveInitOnBlockEvent(event, blockName, callback, 'findBlocksOn');
    },

    /**
     * Helper for live initialization for a different block's event inside the current block
     * @static
     * @protected
     * @param {String} event Event name
     * @param {String} blockName Name of the block that should trigger a reaction when initialized
     * @param {Function} [callback] Handler to be called after successful initialization in the new block's context
     * @returns {BEM.DOM}
     */
    liveInitOnBlockInsideEvent: function(event, blockName, callback) {
        return this._liveInitOnBlockEvent(event, blockName, callback, 'findBlocksOutside');
    },

    /**
     * Adds a live event handler to a block, based on a specified element where the event will be listened for
     * @static
     * @protected
     * @param {jQuery} [ctx] The element in which the event will be listened for
     * @param {String} e Event name
     * @param {Object} [data] Additional information that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [fnCtx] Handler's context
     */
    on: function(ctx, e, data, fn, fnCtx) {
        return ctx.jquery ?
            this._liveCtxBind(ctx, e, data, fn, fnCtx) :
            this.__base(ctx, e, data, fn);
    },

    /**
     * Removes the live event handler from a block, based on a specified element where the event was being listened for
     * @static
     * @protected
     * @param {jQuery} [ctx] The element in which the event was being listened for
     * @param {String} e Event name
     * @param {Function} [fn] Handler
     * @param {Object} [fnCtx] Handler context
     * @returns {BEM.DOM}
     */
    un: function(ctx, e, fn, fnCtx) {
        return ctx.jquery ?
            this._liveCtxUnbind(ctx, e, fn, fnCtx) :
            this.__base(ctx, e, fn);
    },

    /**
     * Adds a live event handler to a block, based on a specified element where the event will be listened for
     * @deprecated Use on
     * @static
     * @protected
     * @param {jQuery} ctx The element in which the event will be listened for
     * @param {String} e Event name
     * @param {Object} [data] Additional information that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [fnCtx] Handler context
     * @returns {BEM.DOM}
     */
    liveCtxBind: function(ctx, e, data, fn, fnCtx) {
        return this._liveCtxBind(ctx, e, data, fn, fnCtx);
    },

    /**
     * Adds a live event handler to a block, based on a specified element where the event will be listened for
     * @static
     * @private
     * @param {jQuery} ctx The element in which the event will be listened for
     * @param {String} e  Event name
     * @param {Object} [data] Additional information that the handler gets as e.data
     * @param {Function} fn Handler
     * @param {Object} [fnCtx] Handler context
     * @returns {BEM.DOM}
     */
    _liveCtxBind: function(ctx, e, data, fn, fnCtx) {
        var _this = this;

        if(typeof e == 'string') {
            if($.isFunction(data)) {
                fnCtx = fn;
                fn = data;
                data = undefined;
            }

            if(e.indexOf(' ') > -1) {
                e.split(' ').forEach(function(e) {
                    _this._liveCtxBind(ctx, e, data, fn, fnCtx);
                });
            } else {
                var ctxE = _this._buildCtxEventName(e),
                    storage = liveEventCtxStorage[ctxE] ||
                        (liveEventCtxStorage[ctxE] = {counter: 0, ctxs: {}});

                ctx.each(function() {
                    var ctxId = $.identify(this),
                        ctxStorage = storage.ctxs[ctxId];
                    if(!ctxStorage) {
                        ctxStorage = storage.ctxs[ctxId] = {};
                        ++storage.counter;
                    }
                    ctxStorage[$.identify(fn) + (fnCtx ? $.identify(fnCtx) : '')] = {
                        fn: fn,
                        data: data,
                        ctx: fnCtx
                    };
                });
            }
        } else {
            $.each(e, function(e, fn) {
                _this._liveCtxBind(ctx, e, fn, data);
            });
        }

        return _this;
    },

    /**
     * Removes a live event handler from a block, based on a specified element where the event was being listened for
     * @deprecated Use on
     * @static
     * @protected
     * @param {jQuery} ctx The element in which the event was being listened for
     * @param {String} e Event name
     * @param {Function} [fn] Handler
     * @param {Object} [fnCtx] Handler context
     * @returns {BEM.DOM}
     */
    liveCtxUnbind: function(ctx, e, fn, fnCtx) {
        return this._liveCtxUnbind(ctx, e, fn, fnCtx);
    },

    /**
     * Removes a live event handler from a block, based on a specified element where the event was being listened for
     * @static
     * @private
     * @param {jQuery} ctx The element in which the event was being listened for
     * @param {String} e Event name
     * @param {Function} [fn] Handler
     * @param {Object} [fnCtx] Handler context
     * @returns {BEM.DOM}
     */
    _liveCtxUnbind: function(ctx, e, fn, fnCtx) {
        var _this = this,
            storage = liveEventCtxStorage[e = _this._buildCtxEventName(e)];

        if(storage) {
            ctx.each(function() {
                var ctxId = $.identify(this, true),
                    ctxStorage;
                if(ctxId && (ctxStorage = storage.ctxs[ctxId])) {
                    fn && delete ctxStorage[$.identify(fn) + (fnCtx ? $.identify(fnCtx) : '')];
                    if(!fn || $.isEmptyObject(ctxStorage)) {
                        storage.counter--;
                        delete storage.ctxs[ctxId];
                    }
                }
            });
            storage.counter || delete liveEventCtxStorage[e];
        }

        return _this;
    },

    /**
     * Retrieves the name of an element nested in a block
     * @static
     * @private
     * @param {jQuery} elem Nested element
     * @returns {String|undefined}
     */
    _extractElemNameFrom: function(elem) {
        if(elem.__bemElemName) {
            return elem.__bemElemName;
        }

        var matches = elem[0].className.match(this._buildElemNameRE());
        return matches ? matches[1] : undefined;
    },

    /**
     * Retrieves block parameters from a DOM element
     * @static
     * @param {HTMLElement} domNode DOM node
     * @returns {Object}
     */
    extractParams: extractParams,

    /**
     * Builds a prefix for the CSS class of a DOM element or nested element of the block, based on modifier name
     * @static
     * @private
     * @param {String} modName Modifier name
     * @param {jQuery|String} [elem] Element
     * @returns {String}
     */
    _buildModClassPrefix: function(modName, elem) {
        return buildClass(this._name) +
               (elem ?
                   ELEM_DELIM + (typeof elem === 'string' ? elem : this._extractElemNameFrom(elem)) :
                   '') +
               MOD_DELIM + modName + MOD_DELIM;
    },

    /**
     * Builds a regular expression for extracting modifier values from a DOM element or nested element of a block
     * @static
     * @private
     * @param {String} modName Modifier name
     * @param {jQuery|String} [elem] Element
     * @param {String} [quantifiers] Regular expression quantifiers
     * @returns {RegExp}
     */
    _buildModValRE: function(modName, elem, quantifiers) {
        return new RegExp(
            '(\\s|^)' + this._buildModClassPrefix(modName, elem) + '(' + NAME_PATTERN + ')(?=\\s|$)',
            quantifiers
        );
    },

    /**
     * Builds a regular expression for extracting names of elements nested in a block
     * @static
     * @private
     * @returns {RegExp}
     */
    _buildElemNameRE: function() {
        return new RegExp(this._name + ELEM_DELIM + '(' + NAME_PATTERN + ')(?:\\s|$)');
    },

    /**
     * Builds a CSS selector corresponding to the block/element and modifier
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String} [modVal] Modifier value
     * @returns {String}
     */
    buildSelector: function(elem, modName, modVal) {
        return '.' + buildClass(this._name, elem, modName, modVal);
    },

    /**
     * Returns a block instance by unique ID
     * @deprecated
     * @param {String} [uniqId]
     * @returns {BEM.DOM}
     */
    getBlockByUniqId: function(uniqId) {
        return uniqIdToBlock[uniqId];
    },

    /**
     * Returns the size of the current window
     * @returns {Object} Object with width and height fields
     */
    getWindowSize: function() {
        return {
            width: win.width(),
            height: win.height()
        };
    }
});

/**
 * Set default scope after DOM ready
 */
$(function() {
    BEM.DOM.scope = $('body');
});
})(BEM, jQuery);

/* end: ../../../libs/islands/common.blocks/i-bem/__dom/i-bem__dom.js */
/* begin: ../../../libs/islands/common.blocks/i-global/i-global.js */

BEM.DOM.decl('i-global', {

    onSetMod: {
        js: {
            inited: function() {
                // Удаляем системные свойства
                this.del(this.__self._params = $.extend({}, this.params), 'uniqId', 'name');

                var params = this.__self._params;

                params['passport-msg'] || (params['passport-msg'] = params.id);

                if(params['show-counters'] === undefined) {
                    params['show-counters'] = Math.round(Math.random() * 100) <= params['show-counters-percent'];
                }
                params.locale = params.lang;
            }
        }
    },

    getDefaultParams: function() {
        return {
            id: '',
            login: Lego.isSessionValid() ? $.cookie('yandex_login') || '' : '',
            yandexuid: $.cookie('yandexuid'),
            lang: 'ru',
            tld: 'ru',
            retpath: encodeURI($.decodeURI(location.href)), // LEGO-8443 + LEGO-9226
            'passport-host': 'https://passport.yandex.ru',
            'pass-host': 'https://pass.yandex.ru',
            'social-host': 'https://social.yandex.ru',
            'lego-path': '/lego',
            'show-counters-percent': 100
        };
    }

}, {

    param: function(name, value) {
        if(typeof value !== 'undefined') {
            this._params && (this._params[name] = value);
        } else {
            return (this._params || {})[name];
        }
    }
});

/* end: ../../../libs/islands/common.blocks/i-global/i-global.js */
/* begin: ../../../libs/islands/common.blocks/i-common/__init/i-common__init.js */
(function($, Lego) {
if(!Lego) {
    Lego = window.Lego = {};
}
// Использует cookie.js и check-session.js. Без них не работает.

/**
 * Инициализирует Лего некоторыми параметрами (для вариативности в пределах разных страниц).
 *
 * @param {Object} params объект Лего-параметров, необходимые параметры инициализируются значениями по умолчанию
 *        params.login логин текущего пользователя ('' для неавторизованного)
 *        params.locale двухбуквенный код локали в нижнем регистре
 *        params.id идентификатор сервиса
 *        params['show-counters-percent'] процент срабатывания счётчиков Lego.ch() (по умолчанию 100)
 *
 * @return {Object} Возвращает установленные параметры с учетом значений по умолчанию.
 */
Lego.init || (Lego.init = function(params) {
    (params = Lego.params = $.extend(
        {
            id: '',
            login: Lego.isSessionValid() ? Lego.getCookie('yandex_login') || '' : '',
            yandexuid: Lego.getCookie('yandexuid'),
            locale: 'ru',
            retpath: window.location.toString(),
            'passport-host': 'https://passport.yandex.ru',
            'pass-host': 'https://pass.yandex.ru',
            'passport-msg': params.id,
            'social-host': 'https://social.yandex.ru',
            'lego-path': '/lego',
            'show-counters-percent': 100
        },
        params,
        Lego.params))
        ['show-counters'] = Math.round(Math.random() * 100) <= params['show-counters-percent'];

    BEM.blocks['i-global']._params || $.extend(BEM.blocks['i-global']._params = {}, params);

    return params;
});

Lego.block || (Lego.block = {});

Lego.blockInit || (Lego.blockInit = function(context, blockSelector) {
    context = context || document;
    blockSelector = blockSelector || '.g-js';
    $(context).find(blockSelector).each(function() {
        var block = $(this),
            params = this.onclick ? this.onclick() : {},
            name = params.name || '',
            init = Lego.block[name];
        if(init && !block.data(name)) {
            init.call(block, params);
            block
                .data(name, true)
                .addClass(name + '_js_inited');
        }
    });
});

Lego.blockInitBinded || (Lego.blockInitBinded = Boolean($(document).ready(function() { Lego.blockInit() })));
})(jQuery, window.Lego);

/* end: ../../../libs/islands/common.blocks/i-common/__init/i-common__init.js */
/* begin: ../../../libs/islands/common.blocks/i-ua/i-ua.js */
(function(win, ua) {
    var devicePixelRatio = 1,
        isHiDpi = false;

    // http://stackoverflow.com/questions/16383503/window-devicepixelratio-does-not-work-in-ie-10-mobile
    if('deviceXDPI' in screen && 'logicalXDPI' in screen) {
        // Internet Explorer
        devicePixelRatio = screen.deviceXDPI / screen.logicalXDPI;
    } else if('devicePixelRatio' in win) {
        // Standard way
        devicePixelRatio = win.devicePixelRatio;
    }

    if(typeof win.matchMedia === 'function') {
        // In fact, HiDPI begins from 1.3dppx.
        // There is a devices list for example: http://bjango.com/articles/min-device-pixel-ratio/
        // 124dpi (used for IE) ~ 1.3dppx for now,
        // but by standard 'dpi' means dots-per-CSS-inch, not dots-per-physical-inch
        var hiDpiQuery =
            'only screen and (-webkit-min-device-pixel-ratio: 1.3), ' +
            'only screen and (min-resolution: 1.3dppx), ' +
            'only screen and (min-resolution: 124dpi)';
        isHiDpi = win.matchMedia(hiDpiQuery).matches;
    } else {
        isHiDpi = (devicePixelRatio >= 1.3);
    }

    var browser = {};

    if(/msie|trident/i.test(ua)) {
        browser.ie = parseInt(ua.split(/msie|rv:/i)[1], 10);
    } else if(win.opera) {
        browser.opera = parseInt(win.opera.version(), 10);
    }

    var platform = {},
        device = {},
        match;

    if((match = ua.match(/Windows\sPhone[^\d]*\s([\d.]+)/))) {
        platform.wp = match[1];
    } else if((match = ua.match(/Android\s+([\d.]+)/))) {
        platform.android = match[1];
    } else if(ua.match(/\sHTC[\s_].*AppleWebKit/)) {
        // По умолчанию у некоторых HTC стоит desktop UA (например, HTC Sensation)
        platform.android = '2.3';
    } else if((match = ua.match(/iPhone\sOS\s([\d_]+)/))) {
        platform.ios = match[1].replace(/_/g, '.');
        device.iphone = true;
    } else if((match = ua.match(/iPad.*OS\s([\d_]+)/))) {
        platform.ios = match[1].replace(/_/g, '.');
        device.ipad = true;
    } else if((match = ua.match(/Bada\/([\d.]+)/))) {
        platform.bada = match[1];
    } else if((match = ua.match(/MSIE\s9/))) {
        platform.wp = '7.5';
    } else {
        platform.other = true;
    }

    /**
     * Block for gathering and providing UserAgent information
     */
    BEM.DOM.decl('i-ua', {

        onSetMod: {
            js: {
                inited: function() {
                    var self = this.__self,
                        platformName = 'other';

                    ['ios', 'android', 'bada', 'wp', 'opera'].some(function(pl) {
                        return self[pl] && (platformName = pl);
                    });

                    this.setMod('platform', platformName);

                    self.hiDpi && this.setMod('hi-dpi', 'yes');
                }
            }
        }
    }, {
        ios: platform.ios,
        iphone: device.iphone,
        ipad: device.ipad,
        android: platform.android,
        bada: platform.bada,
        wp: platform.wp,
        other: platform.other,
        dpr: devicePixelRatio,
        hiDpi: isHiDpi,
        ua: ua,
        ie: browser.ie,
        opera: browser.opera
    });
})(window, navigator.userAgent);

/* end: ../../../libs/islands/common.blocks/i-ua/i-ua.js */
/* begin: ../../../libs/islands/desktop.blocks/header/header.js */
/*
 * TODO: Перенести код про скрытие/раскрытие user в header__nav.js в следующей версии.
 * Пока оставлено тут для обратной совместимости.
 */

/* istanbul ignore next: deprecated */
BEM.DOM.decl('header', {

    onSetMod: {

        js: {

            inited: function() {
                this.__base.apply(this, arguments);

                this.bindToWin('resize', $.throttle(this._onResize, 150));

                this._collapseUserIfNeeded();
            }

        }
    },

    /**
     * Обработчик события resize на window.
     *
     * @private
     */
    _onResize: function() {
        this._collapseUserIfNeeded();
    },

    /**
     * Обработчик события update-name блока user.
     *
     * @private
     */
    _onUserUpdatesName: function() {
        this._collapseBreakpoint = null;
        this._collapseUserIfNeeded();
    },

    /**
     * Скрывает/раскрывает блок user, если блоки в элементе nav не умещаются.
     *
     * @private
     */
    _collapseUserIfNeeded: function() {
        var user = this._getUser();
        user && user.toggleCollapsed(this._getCollapseBreakpoint() >= this.elem('nav').width());
    },

    /**
     * Возвращает ширину, при которой блок user должен скрыться.
     *
     * @private
     * @return {Number} Ширина в пикселях
     */
    _getCollapseBreakpoint: function() {
        if(!this._collapseBreakpoint) {
            this._collapseBreakpoint = this._getNavItemsWidth() + this.__self.NAV_ITEMS_GAP;
        }

        return this._collapseBreakpoint;
    },

    /**
     * Возвращает суммарную ширину элементов, вложенных в __nav.
     *
     * @private
     * @return {Nubmer} Ширина в пикселях
     */
    _getNavItemsWidth: function() {
        var width = 0;

        this.elem('nav').children().each(function() {
            width += $(this).outerWidth(true);
        });

        return width;
    },

    /**
     * Пытается найти блок user внутри себя.
     * Подписывается на событие user#update-name, в случае успеха.
     *
     * @private
     * @return {BEM} Блок user.
     */
    _getUser: function() {
        if(!this._user) {
            this._user = this.findBlockInside('user');
            this._user && this._user.on('update-name', this._onUserUpdatesName, this);
        // NOTE: _isDestructing используется как признак разрушения блока user через .destruct()
        } else if(this._user._isDestructing) {
            // NOTE: Очищаем breakpoint, рассчитанный c учетом ширины разрушенного user.
            this._collapseBreakpoint = null;
            this._user = this.findBlockInside('user');
        }

        return this._user;
    }

}, {
    /**
     * _collapseBreakpoint больше чем суммарная ширина элементов в nav на это число.
     * Нужно для плавности скрытия/раскрытия блока user.
     *
     * @type {Number}
     */
    NAV_ITEMS_GAP: 10,
    live: false
});

/* end: ../../../libs/islands/desktop.blocks/header/header.js */
/* begin: ../../common.blocks/header/header.js */
BEM.DOM.decl('header', {
    onSetMod: {
        js: {
            inited: function inited() {
                this.findBlockInside(this.elem('get-started'), 'button2').on('click', function () {
                    BEM.blocks['contact-us'].trigger('show');
                });

                this.bindTo(this.elem('demo'), 'click', function (e) {
                    e.preventDefault();
                    $('body').animate({
                        scrollTop: $('#demo').offset().top
                    }, 800);
                });
            }
        }
    }
});
/* end: ../../common.blocks/header/header.js */
/* begin: ../../common.blocks/sticky-header/sticky-header.js */
BEM.DOM.decl('sticky-header', {
    onSetMod: {
        js: {
            inited: function inited() {
                this.findBlockInside('button2').on('click', this._onButtonClick, this);

                $(window).scroll($.throttle(this._onScroll.bind(this), 300));
            }
        }
    },

    _onButtonClick: function _onButtonClick() {
        BEM.blocks['contact-us'].trigger('show', { plan: 'not-yet' });
        // this._alwaysHide = true;
        this.delMod('visible');
        dataLayer.push({ event: 'get-started-scroll' });
    },
    _onScroll: function _onScroll() {
        if (this.__self.win.scrollTop() > 900 && !this._alwaysHide) {
            this.setMod('visible', 'yes');
        } else {
            this.delMod('visible');
        }
    }
});
/* end: ../../common.blocks/sticky-header/sticky-header.js */
/* begin: ../../common.blocks/uploader/uploader.js */
BEM.DOM.decl('uploader', {
    onSetMod: {
        js: {
            inited: function inited() {
                this.fileInput = this.elem('input-upload');
                this.urlInput = this.findBlockOn(this.elem('input-url'), 'input');

                this.bindTo(this.fileInput, 'change', this._onImageURL);
            }
        }
    },

    _showError: function _showError(err) {
        BEM.blocks['info-popup'].trigger('message', {
            message: err,
            type: 'error'
        });
    },
    _onUploadClick: function _onUploadClick() {
        this.fileInput.trigger('click');
        dataLayer.push({ event: 'upload-click' });
    },
    _onImageURL: function _onImageURL(e) {
        e && e.preventDefault();

        dataLayer.push({ event: 'upload-submit-url' });

        var file = this.fileInput[0].files[0],
            url = this.urlInput.val();

        if (file || url) {
            this.trigger('image-selected', { file: file, url: url });
        } else {
            this._showError('Please upload a photo or paste a link');
        }
    },
    reset: function reset() {
        this.fileInput.val('');
        this.urlInput.val('');
    }
}, {
    live: function live() {
        this.liveInitOnBlockInsideEvent('click', 'button2', function (e) {
            if (e.block.hasMod('type', 'submit')) {
                this._onImageURL(e);
            } else {
                this._onUploadClick();
            }
        });

        this.liveBindTo('submit', function (e) {
            this._onImageURL(e);
        });
    }
});
/* end: ../../common.blocks/uploader/uploader.js */
/* begin: ../../../libs/d-blocks/common.blocks/info-popup/info-popup.js */
BEM.DOM.decl('info-popup', {

    onSetMod: {
        js: {
            inited: function() {
                this.messageEl = this.elem('message');
                this.modal = this.findBlockOn('modal');

                this
                    .findBlockInside('controls', 'button2')
                    .on('click', this._onCloseClick, this);

                this.__self.on('message', this._onMessage, this);
            }
        }
    },

    close: function() {
        this.modal.delMod('visible');
        return this;
    },

    open: function() {
        this.modal.setMod('visible', 'yes');
        return this;
    },

    setMessage: function(message) {
        this.messageEl.html(message);
        return this;
    },

    _onCloseClick: function(e, data) {
        this.close();
        // fix for not closing underlying modal when click on OK in info-popup
        data.domEvent.stopImmediatePropagation();
    },

    _onMessage: function(e, data) {
        this
            .setMessage(data.message)
            .open();

        this.setMod('type', data.type || '');
    }

}, {
    live: function() {
        this.liveBindTo('close', 'click', function() {
            this._onCloseClick();
        });

        return false;
    }

});

/* end: ../../../libs/d-blocks/common.blocks/info-popup/info-popup.js */
/* begin: ../../../libs/islands/common.blocks/popup2/popup2.js */
/**
 * Popup2
 *
 * @param {Number} [zIndexGroupLevel=0] Уровень слоев z-index.
 */
BEM.DOM.decl('popup2', {
    /**
     * Генерируется перед открытием попапа. В момент срабатывания события модификатор _visible_yes еще не выставлен.
     *
     * @event popup2#beforeOpen
     */

    /**
     * Генерируется перед закрытием попапа. В момент события модификатор _visible_yes еще не убран.
     *
     * @event popup2#beforeClose
     */
    onSetMod: {
        js: {
            inited: function() {
                this._parentPopup = undefined; // Тут важен undefined. Означает, что попап еще не искали.
                this._zIndex = null;
                this._zIndexGroupLevel = null;
                this._isAttachedToScope = false;
            }
        },

        visible: {
            yes: function() {
                this.trigger('beforeOpen');

                if(!this._isAttachedToScope) {
                    BEM.DOM.scope.append(this.domElem);
                    this._isAttachedToScope = true;
                }

                this._captureZIndex()
                    ._bindToParentPopup()
                    .bindTo('pointerdown pointerclick', this._setPreventHideByClick);
            },

            '': function() {
                this.trigger('beforeClose')
                    ._releaseZIndex()
                    ._unbindFromParentPopup()
                    .unbindFrom('pointerdown pointerclick');
            }
        }
    },

    /**
     * @protected
     */
    destruct: function() {
        this.delMod('visible');

        this.__base.apply(this, arguments);
    },

    /**
     * Устанавливает контент. Не экранирует, инициализирует все блоки без live-инициализации.
     *
     * @param {String|jQuery} content
     * @returns {popup} this
     */
    setContent: function(content) {
        BEM.DOM.update(this.domElem, content);
        return this;
    },

    /**
     * @private
     */
    _calcZIndexGroupLevel: function() {
        var res = this.params.zIndexGroupLevel,
            parentPopup = this._getParentPopup();

        if(parentPopup) {
            res += parentPopup._zIndexGroupLevel;
        }

        return res;
    },

    /**
     * Выставляет себе и всем родительским попапам флаг для предотвращения закрытия по клику.
     * @private
     */
    _setPreventHideByClick: function() {
        var curPopup = this;
        do {
            curPopup._preventHideByClick = true;
            curPopup = curPopup._getParentPopup();
        } while(curPopup);
    },

    /**
     * @private
     */
    _bindToParentPopup: function() {
        var parentPopup = this._getParentPopup();
        parentPopup && parentPopup.on('beforeClose', this._onParentPopupClose, this);

        return this;
    },

    /**
     * @private
     */
    _unbindFromParentPopup: function() {
        this._parentPopup && this._parentPopup.un('beforeClose', this._onParentPopupClose, this);
        this._parentPopup = undefined;

        return this;
    },

    /**
     * @private
     */
    _onParentPopupClose: function() {
        this.delMod('visible');
    },

    /**
     * @private
     */
    _getParentPopup: function() {
        return this._parentPopup;
    },

    /**
     * Занимает наименьший свободный z-index в стеке для своего уровня.
     * Выставляет его DOM-элементу.
     *
     * @private
     */
    _captureZIndex: function() {
        if(this._zIndexGroupLevel === null) {
            this._zIndexGroupLevel = this._calcZIndexGroupLevel();
        }

        var visiblePopupsZIndexes = this.__self._visiblePopupsZIndexes,
            level = this._zIndexGroupLevel,
            zIndexes = visiblePopupsZIndexes[level],
            prevZIndex = this._zIndex;

        if(!zIndexes) {
            zIndexes = visiblePopupsZIndexes[level] = [(level + 1) * this.__self.ZINDEX_FACTOR];
        }

        this._zIndex = zIndexes[zIndexes.length - 1] + 1;
        zIndexes.push(this._zIndex);

        if(this._zIndex !== prevZIndex) {
            this.domElem.css('z-index', this._zIndex);
        }

        return this;
    },

    /**
     * Освобождает z-index в стеке.
     * @private
     */
    _releaseZIndex: function() {
        var zIndexes = this.__self._visiblePopupsZIndexes[this._zIndexGroupLevel];
        zIndexes.splice(zIndexes.indexOf(this._zIndex), 1);

        return this;
    },

    /**
     * Освобождает z-index в стеке, пересчитывает заново свой уровень (нужно, если попап переместили к другому anchor)
     * и занимает z-index заново.
     * @private
     */
    _recaptureZIndex: function() {
        this._releaseZIndex();
        this._zIndexGroupLevel = null;

        return this._captureZIndex();
    },

    /**
     * @protected
     */
    getDefaultParams: function() {
        return {
            zIndexGroupLevel: 0
        };
    }
}, {
    live: true,

    /**
     * Хранит стеки всех z-index для открытых попапов. Имеет такую структуру:
     * {
     *    0: [1000, 1001, 1002], // ключ - это уровень, значения в массиве - это занятые z-index-ы
     *    9: [10000, 10001]
     *    // ..
     * }
     *
     * @private
     */
    _visiblePopupsZIndexes: {},

    /**
     * @private
     */
    ZINDEX_FACTOR: 1000
});

/* end: ../../../libs/islands/common.blocks/popup2/popup2.js */
/* begin: ../../../libs/islands/common.blocks/keycodes/keycodes.js */
BEM.decl('keycodes', {}, {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46,

    /**
     * Проверка соответствия кода клавиши одному из переданных названий.
     *
     * @example
     * BEM.blocks.keycodes.is(e.keyCode, 'SPACE', 'ENTER');
     *
     * @param {Number} code Код клавиши.
     * @param {...String|String[]} name Названия клавиш.
     * @returns {Boolean}
     */
    is: function(code, name) {
        return (Array.isArray(name) ? name : Array.prototype.slice.call(arguments, 1)).some(function(name) {
            return this[name] === code;
        }, this);
    }
});

/* end: ../../../libs/islands/common.blocks/keycodes/keycodes.js */
/* begin: ../../../libs/islands/common.blocks/control/control.js */
BEM.DOM.decl('control', {
    onSetMod: {
        focused: {
            yes: function() {
                if(this.hasMod('disabled')) {
                    return false;
                }

                if(!this._focused) {
                    this._focus();
                }
            },

            '': function() {
                if(this._focused) {
                    this._blur();
                }
            }
        },

        disabled: {
            '*': function(modName, modVal) {
                var control = this._getControl(),
                    inDisabling = Boolean(modVal);

                control
                    .prop('disabled', inDisabling)
                    .attr('aria-disabled', inDisabling);

                control.attr('tabindex', inDisabling ? null : this.params._tabindex);
            },

            yes: function() {
                this.delMod('focused');
            }
        }
    },

    /**
     * @private
     */
    _focus: function() {
        this._getControl().focus();
    },

    /**
     * @private
     */
    _blur: function() {
        this._getControl().blur();
    },

    /**
     * @private
     */
    _getControl: function() {
        var control = this.elem('control');
        return control.length > 0 ? control : this.domElem;
    },

    /**
     * @private
     */
    _onFocusin: function() {
        this._focused = true;
        this.setMod('focused', 'yes')
            .bindTo('focusout', this._onFocusout);
    },

    /**
     * @private
     */
    _onFocusout: function() {
        this._focused = false;
        this.delMod('focused')
            .unbindFrom('focusout');
    }
}, {
    live: function() {
        this.liveBindTo('focusin', function(e) {
            this._onFocusin(e);
        });

        // https://st.yandex-team.ru/ISL-1832
        // Prevent ios8+ from autoscroll/autozoom to the input on focus.
        BEM.blocks['i-ua'].ios >= 8 && this.liveBindTo('control', 'focusin', function(e) {
            e.preventDefault();
        });
    }
});

/* end: ../../../libs/islands/common.blocks/control/control.js */
/* begin: ../../../libs/islands/common.blocks/i-ua/__input/i-ua__input.js */
BEM.DOM.decl('i-ua', {}, {
    placeholder: 'placeholder' in document.createElement('input')
});

/* end: ../../../libs/islands/common.blocks/i-ua/__input/i-ua__input.js */
/* begin: ../../../libs/islands/common.blocks/i-system/i-system.js */
(function() {
var timer,
    counter = 0,
    isIdle = false,
    idleInterval = 0,
    channel = BEM.channel('sys'),
    // Необходимо, так как в тестах может подмениться на jasmine.clock.
    _setTimeout = window.setTimeout,
    TICK_INTERVAL = 50;

/**
 * System channel for tick, idle, wakeup messages
 */
BEM.decl('i-system', {}, {

    start: function() {
        $(document).bind('mousemove keydown', function() {
            idleInterval = 0;
            if(isIdle) {
                isIdle = false;
                channel.trigger('wakeup');
            }
        });

        this._tick();
    },

    _tick: function _tick() {
        channel.trigger('tick', {counter: counter++});

        if(!isIdle && (idleInterval += TICK_INTERVAL) > 3000) {
            isIdle = true;
            channel.trigger('idle');
        }

        timer = _setTimeout(_tick, TICK_INTERVAL);
    }
}).start();
})();

/* end: ../../../libs/islands/common.blocks/i-system/i-system.js */
/* begin: ../../common.blocks/api/api.js */
BEM.decl('api', {

    /**
     * From upload input
     * @param {File} file
     */

    setFile: function setFile(file) {
        this.file = file;
        return this;
    },


    /**
     * From webcam
     * @param {Blob} blob
     */
    setBlob: function setBlob(blob) {
        this.blob = blob;
        return this;
    },


    /**
     * From text input for URL
     * @param {String} url
     */
    setURL: function setURL(url) {
        this.url = url;
        return this;
    },
    reset: function reset() {
        this.file = undefined;
        this.blob = undefined;
        this.url = undefined;

        return this;
    },


    /**
     * Отправляет картинку на сервер ajax-ом для анализа
     * @returns {Promise}
     * @private
     */
    send: function send() {
        var formData = new FormData();

        if (this.file) {
            formData.append('photo', this.file);
        } else if (this.blob) {
            formData.append('photo', this.blob, 'img-from-webcam.' + this.file.type.split('/')[1]);
        } else if (this.url) {
            formData.append('url', this.url);
        }

        return $.ajax({
            type: 'post',
            url: this._apiUrl,
            data: formData,
            dataType: 'json',
            cache: false,
            contentType: false,
            processData: false
        });
    }
});

BEM.decl({ baseBlock: 'api', block: 'api-cv' }, {
    onSetMod: {
        js: {
            inited: function inited() {
                this._apiUrl = '/analyze';
            }
        }
    }
});

BEM.decl({ baseBlock: 'api', block: 'api-search' }, {
    onSetMod: {
        js: {
            inited: function inited() {
                this._apiUrl = '/find-dups';
            }
        }
    }
});
/* end: ../../common.blocks/api/api.js */
/* begin: ../../common.blocks/use-case/use-case.js */
BEM.DOM.decl('use-case', {}, {
    live: function live() {
        this.liveInitOnBlockInsideEvent('change', 'tabs', function (e, data) {
            dataLayer.push({ event: this.params.name + '-pane-' + (parseInt(data.currentIndex) + 1) });
        });
    }
});
/* end: ../../common.blocks/use-case/use-case.js */
/* begin: ../../../libs/islands/common.blocks/tabs-panes/tabs-panes.js */
BEM.DOM.decl('tabs-panes', {

    /**
     * @private
     */
    onElemSetMod: {
        pane: {
            active: {
                yes: function(elem, modName, modVal) {
                    var prev = this.findPane('active', 'yes');

                    prev.attr('aria-expanded', false);
                    elem.attr('aria-expanded', true);

                    this.delMod(prev, 'active');
                }
            }
        }
    },

    /**
     * Обработчик события `change` на контроле.
     *
     * @private
     * @param {$.Event} e
     * @param {Object} data
     */
    _onControlChange: function(e, data) {
        this.setMod(this.findPane().eq(data.currentIndex), 'active', 'yes');
    },

    /**
     * Возвращает jQuery-коллекцию элементов панелек.
     *
     * Рекомендуется использовать именно этот метод для получения панелек, т.к. он возвращает только панельки,
     * относящиеся к текущему блоку. Если вложить tabs-panes в другой tabs-panes, то при прямом вызове
     * tabsPanes.elem('pane') будут возвращены панельки внешнего и внутреннего блоков.
     *
     * @public
     * @param {String} modName
     * @param {String} modVal
     * @returns {jQuery}
     */
    findPane: function(modName, modVal) {
        return this.domElem.children(this.buildSelector('pane', modName, modVal));
    }
}, {
    /**
     * Возвращает список доступных блоков, способных работать в качестве контрола-переключателя
     * для панели. Доопределите этот метод для добавления своих блоков.
     *
     * @protected
     * @returns {String[]}
     */
    getSupportedControls: function() {
        return ['tabs'];
    },

    live: function() {
        this.getSupportedControls().forEach(function(block) {
            BEM.blocks[block] && this.liveInitOnBlockEvent('change', block, function(e, data) {
                this._onControlChange(e, data);
            });
        }, this);
    }
});

/* end: ../../../libs/islands/common.blocks/tabs-panes/tabs-panes.js */
/* begin: ../../common.blocks/demo/demo.js */
BEM.DOM.decl('demo', {
    relations: {
        adult: 'adult-or-inappropriate-content',
        // children: 'children',
        female: 'female',
        male: 'male',
        many: 'multiple-people',
        other: 'other'
    },

    onSetMod: {
        js: {
            inited: function inited() {
                this.apiCv = BEM.create('api-cv');
                this.apiSearch = BEM.create('api-search');

                this.uploader = this.findBlockInside('uploader');

                this.findBlockInside('again', 'button2').on('click', this._onAgainClick, this);
            }
        }
    },

    _onImageSelected: function _onImageSelected(file, url) {
        this._classify(file, url)._searchDups(file, url)._displayImage(file, url);

        this.setMod(this.elem('content'), 'selected', 'results');
        this.setMod('cv', 'loading');
        this.setMod('dups', 'loading');
    },
    _classify: function _classify(file, url) {
        var analyzePromise;

        if (file) {
            analyzePromise = this.apiCv.setFile(file).send();
        } else if (url) {
            analyzePromise = this.apiCv.setURL(url).send();
        }

        analyzePromise.then(this._onClassifySuccess.bind(this)).fail(this._onClassifyError.bind(this));

        return this;
    },


    /**
     * @private
     */
    _onClassifySuccess: function _onClassifySuccess(data) {
        var _this = this;

        var results = this.findBlockInside('results-cv'),
            elem,
            score;

        data.result.scores.forEach(function (s) {
            elem = results.elem('item', 'name', _this.relations[s.className]);
            score = Math.round(s.score * 100);

            elem.find('.results-cv__inner-bar').css('width', score + '%');

            elem.find('.results-cv__percent').text(score + '%');
        });

        this.delMod('cv');
    },
    _onClassifyError: function _onClassifyError(err) {
        var errorMessage = 'Cannot download image';

        if (err.responseJSON && err.responseJSON.error) {
            if (err.responseJSON.error.indexOf('403') !== -1) {
                errorMessage = 'No access to image by this URL.';
            } else {
                errorMessage = err.responseJSON.error;
            }
        }

        this._showError(errorMessage);

        this.delMod('cv');
    },
    _searchDups: function _searchDups(file, url) {
        var searchPromise;

        if (file) {
            searchPromise = this.apiSearch.setFile(file).send();
        } else if (url) {
            searchPromise = this.apiSearch.setURL(url).send();
        }

        searchPromise.then(this._onSearchSuccess.bind(this)).fail(this._onSearchError.bind(this));

        return this;
    },


    /*
     * @private
     */
    _onSearchSuccess: function _onSearchSuccess(data) {
        if (data.length > 0) {
            this.elem('results-dups').html(data.map(function (d) {
                return '<a class="justifier__item" href="http://' + d.site + '" style="background-image: url(' + d.thumb + ')" target="_blank"></a>';
            }).join(''));
        } else {
            this.elem('results-dups').text('(No duplicates found)');
        }

        this.delMod('dups');
    },
    _onSearchError: function _onSearchError(err) {
        var errorMessage = 'Cannot download image';

        if (err.responseJSON && err.responseJSON.error) {
            if (typeof err.responseJSON.error === 'string' && err.responseJSON.error.indexOf('403') !== -1) {
                errorMessage = 'No access to image by this URL.';
            } else {
                errorMessage = err.responseJSON.error;
            }
        }

        this._showError(errorMessage);
        this.delMod('dups');
    },
    _showError: function _showError(err) {
        BEM.blocks['info-popup'].trigger('message', {
            message: err,
            type: 'error'
        });
        this.setMod(this.elem('content'), 'selected', 'form');
    },
    _displayImage: function _displayImage(file, url) {
        if (file) {
            this._displayImageByFile(file);
        } else if (url) {
            this._displayImageByURL(url);
        }

        return this;
    },
    _displayImageByFile: function _displayImageByFile(file) {
        var _this2 = this;

        var reader = new FileReader();

        reader.onload = function (e) {
            _this2._setImageSrc(e.target.result);
        };

        reader.readAsDataURL(file);
    },
    _displayImageByURL: function _displayImageByURL(url) {
        this._setImageSrc(url);
    },
    _setImageSrc: function _setImageSrc(uri) {
        this.elem('image').css('background-image', 'url(' + uri + ')');
    },
    _onAgainClick: function _onAgainClick() {
        this.setMod(this.elem('content'), 'selected', 'form').delMod('cv').delMod('dups');

        this.uploader.reset();
        this.apiSearch.reset();
        this.apiCv.reset();

        this.elem('results-dups').html('');
        this._setImageSrc('');

        dataLayer.push({ event: 'upload-again-click' });
    }
}, {
    live: function live() {
        this.liveInitOnBlockInsideEvent('image-selected', 'uploader', function (e, data) {
            this._onImageSelected(data.file, data.url);
        });
    }
});
/* end: ../../common.blocks/demo/demo.js */
/* begin: ../../common.blocks/plans/plans.js */
BEM.DOM.decl('plans', {
    onSetMod: {
        js: {
            inited: function inited() {
                BEM.blocks['button2'].on(this.domElem, 'click', this._onChooseClick, this);
            }
        }
    },
    _onChooseClick: function _onChooseClick(e) {
        BEM.blocks['contact-us'].trigger('show', {
            plan: e.block.params.plan
        });
        dataLayer.push({ event: 'get-started-' + e.block.params.plan });
    }
});
/* end: ../../common.blocks/plans/plans.js */
/* begin: ../../common.blocks/contact-us/contact-us.js */
BEM.DOM.decl('contact-us', {
    onSetMod: {
        js: {
            inited: function inited() {
                this.modal = this.findBlockOn('modal');
                this.__self.on('show', this.open, this);
                this.__self.on('hide', this.close, this);

                this.bindTo('close', 'click', this.close);
                this.bindTo('submit', this._onSubmit);
            }
        }
    },

    close: function close() {
        dataLayer.push({ event: 'contact-us-close' });
        this.modal.delMod('visible');
    },
    open: function open(e, data) {
        dataLayer.push({ event: 'contact-us-open' });
        this.modal.setMod('visible', 'yes');

        if (data && data.plan) {
            this.findBlockInside('radiobox').val(data.plan.toLowerCase());
        }
    },
    _onSubmit: function _onSubmit(e) {
        var _this = this;

        e && e.preventDefault();

        var values = $(this.domElem).serializeArray(),
            data = {};

        if (this._isFormValid(values)) {
            values.forEach(function (v) {
                return data[v.name] = v.value;
            });

            $.post('/handle-form', data).done(function () {
                _this.close();
                _this._showPopup({
                    text: 'Thank you! Your message has been sent. We will be contacting you shortly.',
                    type: 'ok'
                });
                dataLayer.push({ event: 'contact-us-send-ok' });
            }).fail(function () {
                _this._showPopup({
                    text: 'Error sending. Are you still on Internet?',
                    type: 'error'
                });
                dataLayer.push({ event: 'contact-us-send-fail' });
            });
        } else {
            this._showPopup({
                text: 'Please fill e-mail and company name.',
                type: 'error'
            });
        }
    },
    _isFormValid: function _isFormValid(values) {
        for (var i = 0; i < values.length; i++) {
            if (values[i].name === 'e-mail' && values[i].value === '') {
                return false;
            }
            if (values[i].name === 'company-name' && values[i].value === '') {
                return false;
            }
        }

        return true;
    },
    _showPopup: function _showPopup(data) {
        BEM.blocks['info-popup'].trigger('message', {
            message: data.text,
            type: data.type
        });
    }
});
/* end: ../../common.blocks/contact-us/contact-us.js */
/* begin: ../../../libs/d-blocks/common.blocks/d-form/d-form.js */
BEM.DOM.decl('d-form', {

    onSetMod: function() {
        this.helpPopups = {};
    },

    _onHelpOver: function(e) {
        var helpEl = this._getHelpContainer(e.target),
            helpId = helpEl.data('help-id');

        this.bindTo(helpEl, 'pointerleave', this._onHelpLeave);

        if (helpId === undefined) {
            helpId = Math.random();
            helpEl.data('help-id', helpId);

            this.helpPopups[helpId] = this.findBlockInside(helpEl, 'popup2');
            this.helpPopups[helpId].setAnchor(helpEl);
        }

        this.helpPopups[helpId].setMod('visible', 'yes');
    },

    _onHelpLeave: function(e) {
        var helpEl = this._getHelpContainer(e.target),
            helpId = helpEl.data('help-id');

        this.unbindFrom(helpEl, 'pointerleave');

        this.helpPopups[helpId].delMod('visible');
    },

    _getHelpContainer: function(target) {
        return $(target).closest('.d-form__help');
    }

}, {

    live: function() {
        this.liveBindTo('help', 'pointerover', function(e) {
            this._onHelpOver(e);
        });
    }

})

/* end: ../../../libs/d-blocks/common.blocks/d-form/d-form.js */
/* begin: ../../../libs/islands/common.blocks/popup2/_target/popup2_target.js */
/**
 * @param {Number}    [mainOffset=0]       Отступ по основному направлению. Для темы `_normal` по умолчанию `5`.
 * @param {Number}    [secondaryOffset=0]  Отступ по второстепенному направлению.
 * @param {Number}    [viewportOffset=0]   Отступ от границ окна. Для темы `_normal` по умолчанию `5`.
 * @param {String[]}  [directions]         Направления раскрытия.
 */
BEM.DOM.decl({block: 'popup2', modName: 'target'}, {
    /**
     * @private
     */
    onSetMod: {
        js: {
            inited: function() {
                var AVAILABLE_DIRECTIONS = this.__self.AVAILABLE_DIRECTIONS;

                this.params.directions.forEach(function(direction) {
                    if(AVAILABLE_DIRECTIONS.indexOf(direction) === -1) {
                        throw new Error('Can\'t init popup with "' + direction + '" direction. Available directions: ' +
                        AVAILABLE_DIRECTIONS.join(', '));
                    }
                });

                this.__base.apply(this, arguments);

                this._lastPopupDrawingCss = {
                    left: undefined,
                    top: undefined,
                    zIndex: undefined,
                    display: undefined
                };

                this._lastTailDrawingCss = {
                    left: undefined,
                    top: undefined
                };
            }
        },

        visible: {
            yes: function() {
                this.__base.apply(this, arguments);
                this
                    .bindToWin('scroll resize', this._onWinScollAndResize)
                    // Перед перерисовкой выносим попап за viewport и ставим display: block, чтобы правильно
                    // снимались его размеры
                    .setMod('outside', 'yes')
                    .redraw()
                    .delMod('outside');
            },

            '': function() {
                this.__base.apply(this, arguments);
                this.unbindFromWin('scroll resize');
            }
        }
    },

    /**
     * @override
     */
    setContent: function() {
        return this.__base.apply(this, arguments).redraw();
    },

    /**
     * Пересчитывает позицию попапа и выбирает новое направление, если это необходимо.
     *
     * @public
     * @returns {BEM.DOM.popup2} this
     */
    redraw: function() {
        if(!this.hasMod('visible', 'yes') && !this.hasMod('outside', 'yes')) {
            return this;
        }

        var bestDrawingParams = this._calcBestDrawingParams();
        this.setMod('direction', bestDrawingParams.direction);

        if(updateObjectWithParams(this._lastPopupDrawingCss, this._calcDrawingCss(bestDrawingParams))) {
            this.domElem.css(this._lastPopupDrawingCss);
        }

        if(updateObjectWithParams(this._lastTailDrawingCss, this._calcTailDrawingCss(bestDrawingParams))) {
            this.elem('tail').css(this._lastTailDrawingCss);
        }

        return this;

        /**
         * Копирует значения из второго объекта в первый и возвращает true если хотя бы один одно значение было
         * изменено.
         *
         * @private
         * @param {Object} obj
         * @param {Object} params
         * @returns {Boolean}
         */
        function updateObjectWithParams(obj, params) {
            var updated = false;
            Object.keys(params).forEach(function(key) {
                var val = params[key];
                if(obj[key] !== val) {
                    obj[key] = val;
                    updated = true;
                }
            });

            return updated;
        }
    },

    /**
     * @private
     */
    _calcDrawingCss: function(drawingParams) {
        return {
            left: drawingParams.left,
            top: drawingParams.top
        };
    },

    /**
     * @private
     */
    _calcTailDrawingCss: function(drawingParams) {
        return {
            left: drawingParams.tail.left,
            top: drawingParams.tail.top
        };
    },

    /**
     * Возвращает массив возможных параметров раскрытия с максимально доступной площадью.
     * Каждый элемент массива описывает прямоугольную область, в которой может находиться попап. Формат элемента:
     *
     * ```js
     * {
     *     direction: 'bottom-left', // направление
     *     height: 540,              // доступная высота области
     *     width: 1000,              // доступная ширина области
     *     left: 10,                 // левая координата области
     *     top: 30                   // верхняя координата области
     * }
     * ```
     *
     * Не стоит путать параметры `top`/`left` с позицией попапа. Тут эти параметры указывают на позицию доступной
     * области, а не попапа.
     *
     * @public
     * @returns {Object[]}
     */
    calcPossibleDrawingParams: function() {
        var target = this._calcTargetDimensions(),
            viewport = this._calcViewportDimensions(),
            offsets = this._calcOffsets();

        return this.params.directions.map(function(direction) {
            var res = {
                direction: direction,
                width: 0,
                height: 0,
                left: 0,
                top: 0
            };

            if(this._checkMainDirection(direction, 'bottom')) {
                res.top = target.top + target.height + offsets.main;
                res.height = viewport.bottom - res.top - offsets.viewport;
            } else if(this._checkMainDirection(direction, 'top')) {
                res.height = target.top - viewport.top - offsets.main - offsets.viewport;
                res.top = target.top - res.height - offsets.main;
            } else {
                if(this._checkSecondaryDirection(direction, 'center')) {
                    res.height = viewport.bottom - viewport.top - 2 * offsets.viewport;
                    res.top = target.top + (target.height - res.height) / 2;
                } else if(this._checkSecondaryDirection(direction, 'bottom')) {
                    res.height = target.top + target.height - viewport.top - offsets.secondary - offsets.viewport;
                    res.top = target.top + target.height - res.height - offsets.secondary;
                } else if(this._checkSecondaryDirection(direction, 'top')) {
                    res.top = target.top + offsets.secondary;
                    res.height = viewport.bottom - res.top - offsets.viewport;
                }

                if(this._checkMainDirection(direction, 'left')) {
                    res.width = target.left - viewport.left - offsets.main - offsets.viewport;
                    res.left = target.left - res.width - offsets.main;
                } else {
                    res.left = target.left + target.width + offsets.main;
                    res.width = viewport.right - res.left - offsets.viewport;
                }
            }

            if(this._checkSecondaryDirection(direction, 'right')) {
                res.width = target.left + target.width - viewport.left - offsets.secondary - offsets.viewport;
                res.left = target.left + target.width - res.width - offsets.secondary;
            } else if(this._checkSecondaryDirection(direction, 'left')) {
                res.left = target.left + offsets.secondary;
                res.width = viewport.right - res.left - offsets.viewport;
            } else if(this._checkSecondaryDirection(direction, 'center')) {
                if(this._checkMainDirection(direction, 'top', 'bottom')) {
                    res.width = viewport.right - viewport.left - 2 * offsets.viewport;
                    res.left = target.left + target.width / 2 - res.width / 2;
                }
            }

            return res;
        }, this);
    },

    /**
     * Вычисляет лучшие параметры отображения. Под лучшими параметрами понимаются параметры для первого подходящего
     * направления из directions, которое может обеспечить размещение 99% (VIEWPORT_ACCURACY_FACTOR) площади попапа.
     * Если подходящего направления не найдено, то предпочтение отдается направлению, в котором попап открывался
     * последний раз, или первому направлению из списка.
     *
     * @private
     */
    _calcBestDrawingParams: function() {
        var popup = this._calcPopupDimensions(),
            target = this._calcTargetDimensions(),
            viewport = this._calcViewportDimensions(),
            directions = this.params.directions,
            directionsLength = directions.length,
            direction,
            pos,
            viewportFactor,
            bestDirection,
            bestPos,
            bestViewportFactor;

        for(var i = 0; i < directionsLength; i++) {
            direction = directions[i];
            pos = this._calcPos(direction, target, popup);
            viewportFactor = this._calcViewportFactor(pos, viewport, popup);

            if(i === 0 ||
                viewportFactor > bestViewportFactor ||
                (!bestViewportFactor && this.hasMod('direction', direction))
                ) {
                bestDirection = direction;
                bestViewportFactor = viewportFactor;
                bestPos = pos;
            }

            if(bestViewportFactor > this.__self.VIEWPORT_ACCURACY_FACTOR) {
                break;
            }
        }

        return {
            direction: bestDirection,
            left: bestPos.left,
            top: bestPos.top,
            tail: this._calcTailPos(bestDirection, target, popup, bestPos)
        };
    },

    /**
     * @private
     */
    _calcPopupDimensions: function() {
        var popupWidth = this.domElem.outerWidth(),
            popupHeight = this.domElem.outerHeight();

        return {
            width: popupWidth,
            height: popupHeight,
            innerWidth: this.domElem.innerWidth(),
            innerHeight: this.domElem.innerHeight(),
            area: popupWidth * popupHeight
        };
    },

    /**
     * @private
     */
    _calcTailDimension: function() {
        // В IE9 .outerWidth() возвращает ширину элемента, даже если он скрыт, поэтому явно проверяем на display: none;
        var tail = this.elem('tail');
        return tail.length > 0 && tail.css('display') !== 'none' ? this.elem('tail').outerWidth() : 0;
    },

    /**
     * @abstract
     * @private
     */
    _calcTargetDimensions: function() {},

    /**
     * @private
     */
    _calcViewportDimensions: function() {
        var win = BEM.DOM.win,
            winTop = win.scrollTop(),
            winLeft = win.scrollLeft(),
            winWidth = win.width(),
            winHeight = win.height();

        return {
            top: winTop,
            left: winLeft,
            bottom: winTop + winHeight,
            right: winLeft + winWidth
        };
    },

    /**
     * Вычисляет координаты попапа для заданного направления
     *
     * @private
     * @param {String} direction Строка типа bottom-left
     * @param {Object} target    Размеры target-a: top, left, width, height
     * @param {Object} popup     Размеры попапа: width, height, area
     * @returns {Object}         Координаты попапа: left, top
     */
    _calcPos: function(direction, target, popup) {
        var res = {},
            offsets = this._calcOffsets();

        if(this._checkMainDirection(direction, 'bottom')) {
            res.top = target.top + target.height + offsets.main;
        } else if(this._checkMainDirection(direction, 'top')) {
            res.top = target.top - popup.height - offsets.main;
        } else if(this._checkMainDirection(direction, 'left')) {
            res.left = target.left - popup.width - offsets.main;
        } else if(this._checkMainDirection(direction, 'right')) {
            res.left = target.left + target.width + offsets.main;
        }

        if(this._checkSecondaryDirection(direction, 'right')) {
            res.left = target.left + target.width - popup.width - offsets.secondary;
        } else if(this._checkSecondaryDirection(direction, 'left')) {
            res.left = target.left + offsets.secondary;
        } else if(this._checkSecondaryDirection(direction, 'bottom')) {
            res.top = target.top + target.height - popup.height - offsets.secondary;
        } else if(this._checkSecondaryDirection(direction, 'top')) {
            res.top = target.top + offsets.secondary;
        } else if(this._checkSecondaryDirection(direction, 'center')) {
            if(this._checkMainDirection(direction, 'top', 'bottom')) {
                res.left = target.left + target.width / 2 - popup.width / 2;
            } else if(this._checkMainDirection(direction, 'left', 'right')) {
                res.top = target.top + target.height / 2 - popup.height / 2;
            }
        }

        return res;
    },

    _calcTailPos: function(direction, target, popup, pos) {
        var res = {},
            halfOfTail = this._calcTailDimension() / 2;

        if(this._checkMainDirection(direction, 'bottom')) {
            res.top = -halfOfTail;
        } else if(this._checkMainDirection(direction, 'top')) {
            res.top = Math.floor(popup.innerHeight - halfOfTail);
        } else if(this._checkMainDirection(direction, 'left')) {
            res.left = Math.floor(popup.innerWidth - halfOfTail);
        } else if(this._checkMainDirection(direction, 'right')) {
            res.left = -halfOfTail;
        }

        if(this._checkSecondaryDirection(direction, 'right')) {
            res.left = popup.innerWidth - Math.ceil(Math.min(popup.innerWidth, target.width) / 2) - halfOfTail;
        } else if(this._checkSecondaryDirection(direction, 'left')) {
            res.left = Math.ceil(Math.min(popup.innerWidth, target.width) / 2) - halfOfTail;
        } else if(this._checkSecondaryDirection(direction, 'bottom')) {
            res.top = popup.innerHeight - Math.ceil(Math.min(popup.innerHeight, target.height) / 2) - halfOfTail;
        } else if(this._checkSecondaryDirection(direction, 'top')) {
            res.top = Math.ceil(Math.min(popup.innerHeight, target.height) / 2) - halfOfTail;
        } else if(this._checkSecondaryDirection(direction, 'center')) {
            if(this._checkMainDirection(direction, 'top', 'bottom')) {
                res.left = Math.ceil(popup.innerWidth / 2) - halfOfTail;
            } else {
                res.top = Math.ceil(popup.innerHeight / 2) - halfOfTail;
            }
        }

        return res;
    },

    /**
     * Вычисляет коэффициент (factor) пересечения доступной площади для открытия попапа и собственной площади попапа.
     * @private
     */
    _calcViewportFactor: function(pos, viewport, popup) {
        var viewportOffset = this.params.viewportOffset,
            intersectionLeft = Math.max(pos.left, viewport.left + viewportOffset),
            intersectionRight = Math.min(pos.left + popup.width, viewport.right - viewportOffset),
            intersectionTop = Math.max(pos.top, viewport.top + viewportOffset),
            intersectionBottom = Math.min(pos.top + popup.height, viewport.bottom - viewportOffset);

        if(intersectionLeft < intersectionRight && intersectionTop < intersectionBottom) {
            // Есть пересечение
            return (intersectionRight - intersectionLeft) * (intersectionBottom - intersectionTop) / popup.area;
        } else {
            return 0;
        }
    },

    /**
     * @private
     */
    _calcOffsets: function() {
        var params = this.params,
            tailHeight = Math.round(this._calcTailDimension() * Math.SQRT1_2);

        return {
            main: Math.max(params.mainOffset, tailHeight),
            secondary: params.secondaryOffset,
            viewport: params.viewportOffset
        };
    },

    /**
     * @private
     */
    _checkMainDirection: function(direction, mainDirection1, mainDirection2) {
        return direction.indexOf(mainDirection1) === 0 || (mainDirection2 && direction.indexOf(mainDirection2) === 0);
    },

    /**
     * @private
     */
    _checkSecondaryDirection: function(direction, secondaryDirection) {
        return direction.indexOf('-' + secondaryDirection) > 0;
    },

    /**
     * @private
     */
    _checkDirection: function(direction, directionPart) {
        return direction.indexOf(directionPart) >= 0;
    },

    /**
     * @private
     */
    _onWinScollAndResize: function(e) {
        this.redraw();
    },

    /**
     * @protected
     */
    getDefaultParams: function() {
        return $.extend(
            this.__base.apply(this, arguments),
            {
                mainOffset: 0,
                secondaryOffset: 0,
                viewportOffset: 0,
                directions: this.__self.AVAILABLE_DIRECTIONS
            });
    }
}, {
    /**
     * @private
     */
    VIEWPORT_ACCURACY_FACTOR: 0.99,

    /**
     * @private
     */
    AVAILABLE_DIRECTIONS: [
        'bottom-left', 'bottom-center', 'bottom-right',
        'top-left', 'top-center', 'top-right',
        'right-top', 'right-center', 'right-bottom',
        'left-top', 'left-center', 'left-bottom'
    ]
});

/* end: ../../../libs/islands/common.blocks/popup2/_target/popup2_target.js */
/* begin: ../../../libs/islands/common.blocks/radiobox/radiobox.js */
BEM.DOM.decl('radiobox', {

    /**
     * Генерируется при смене активного radiobox-а.
     *
     * @event radiobox#change
     * @param {Object} data              Данные события.
     * @param {jQuery} data.current      Активированный radiobox.
     * @param {jQuery} data.prev         Деактивированный radiobox.
     * @param {Number} data.currentVal   Значение активированного radiobox-а.
     * @param {Number} data.prevVal      Значение деактивированного radiobox-а.
     */

    /**
     * @private
     */
    onSetMod: {
        js: {
            inited: function() {
                this._val = this.findElem(this.elem('radio', 'checked', 'yes'), 'control').val();

                this.elem('control').each((function(i, elem) {
                    var control = $(elem),
                        radio = this.__self._getRadioByElem(control);

                    if(control.isFocused()) {
                        this.setMod(radio, 'focused', 'yes');
                    }

                    if(control.prop('checked')) {
                        this.setMod(radio, 'checked', 'yes');
                    }
                }).bind(this));
            }
        },

        disabled: {
            yes: function() {
                this.setMod(this.elem('radio'), 'disabled', 'yes');
            },

            '': function() {
                this.delMod(this.elem('radio'), 'disabled');
            }
        }
    },

    /**
     * @private
     */
    onElemSetMod: {
        radio: {
            focused: {
                yes: function(elem) {
                    this.delMod(this.elem('radio', 'focused', 'yes'), 'focused');

                    var control = this.findElem(elem, 'control');

                    control.isFocused() || control.focus();

                    this.afterCurrentEvent(function() {
                        this.trigger('focus', {current: elem});
                    });
                },

                '': function(elem) {
                    this.afterCurrentEvent(function() {
                        this.trigger('blur', {prev: elem});
                    });
                }
            },

            checked: {
                yes: function(elem) {
                    var prev = this.elem('radio', 'checked', 'yes'),
                        control = this.findElem(elem, 'control'),
                        prevVal = this._val;

                    this._willSwitch = true; // DEPRECATED
                    this.delMod(prev, 'checked');
                    this._willSwitch = false; // DEPRECATED

                    control.prop('checked', true);
                    this._val = control.val();

                    this.trigger('change', {
                        current: elem,
                        currentVal: this._val,
                        prev: prev,
                        prevVal: prevVal
                    });
                },

                '': function(elem) {
                    var control = this.findElem(elem, 'control'),
                        prevVal = this._val;

                    control.prop('checked', false);
                    this._val = undefined;

                    // DEPRECATED
                    // Флаг _willSwitch выставляется в обработчике _checked_yes.
                    // Если выставлен, значит блок в процессе переключения и не нужно кидать
                    // событие change. Эта логика реализована для обратной совместимости.
                    // В 5.0 нужно перейти на асинхронную генерацию события change в следующем тике.
                    if(!this._willSwitch) {
                        this.trigger('change', {
                            current: $(),
                            currentVal: undefined,
                            prev: elem,
                            prevVal: prevVal
                        });
                    }
                }
            },

            hovered: function(elem) {
                return !this.isDisabled(elem);
            },

            pressed: function(elem) {
                return !this.isDisabled(elem);
            },

            disabled: function(elem, modName, modVal) {
                elem.find(this.buildSelector('control')).prop('disabled', modVal === 'yes');
                if(modVal === 'yes') {
                    this.delMod(elem, 'hovered')
                        .delMod(elem, 'pressed');
                }
            }
        }
    },

    /**
     * Сокращенная форма для проверки модификатора `_disabled_yes`.
     *
     * @public
     * @param {jQuery} radio кнопка, состояние которой необходимо проверить
     * @returns {Boolean}
     */
    isDisabled: function(radio) {
        return this.hasMod(radio, 'disabled', 'yes');
    },

    /**
     * Метод можно вызывать с параметром и без.
     * Вызвав без параметра получаем значение атрибута value элемента radio, соответствующего активной кнопке.
     * Вызвав с параметром, в котором передаем значение атрибута value произвольного элемента radio,
     * делаем активной кнопку, соответствующую этому элементу radio.
     *
     * @public
     * @param {String} [val] Значение атрибута value какого-либо элемента radio данного блока.
     * @returns {String|BEM.DOM} Атрибут value активного элемента radio, либо объект блока
     */
    val: function(val) {
        if(typeof val === 'undefined') {
            return this._val;
        }

        var self = this;
        this.elem('control').each(function(i, control) {
            if(control.value === val) {
                self.setMod(self.__self._getRadioByElem($(control)), 'checked', 'yes');
                return false;
            }
        });
        return self;
    },

    /**
     * Возвращает/устанавливает имя нативного контрола.
     *
     * @public
     * @param {String} [val] Новое имя для контрола.
     * @returns {String|BEM.DOM}
     */
    name: function(val) {
        var control = this.elem('control');

        if(!arguments.length) {
            return control.attr('name');
        }

        control.attr('name', val);

        return this;
    },

    /**
     * Метод позволяет получить активный элемент radio блока.
     *
     * @public
     * @returns {jQuery} DOM elements
     */
    getCurrent: function() {
        return this.findElem('radio', 'checked', 'yes');
    },

    /**
     * Метод позволяет перевести все кнопки блока в состояние «не нажата».
     *
     * @public
     * @returns {BEM.DOM} Объект блока
     */
    uncheckAll: function() {
        this.delMod(this.elem('radio', 'checked', 'yes'), 'checked');
        return this;
    },

    /**
     * Курсор пересек границу __radio (pointerenter).
     *
     * @private
     * @param {jQuery.Event} e
     */
    _onRadioEnter: function(e) {
        this.setMod(e.data.domElem, 'hovered', 'yes');
    },

    /**
     * Курсор ушел за границу __radio (pointerleave).
     *
     * @private
     * @param {jQuery.Event} e
     */
    _onRadioLeave: function(e) {
        this.delMod(e.data.domElem, 'hovered');
    },

    /**
     * Обработчик клика левой кнопки мыши по __radio.
     *
     * @private
     * @param {jQuery} elem
     * @param {jQuery.Event} e
     */
    _onRadioClick: function(elem, e) {
        this.isDisabled(elem) || this.setMod(elem, 'focused', 'yes');
    },

    /**
     * Обработчик изменения значения контрола.
     *
     * @private
     * @param {jQuery.Event} e
     */
    _onChange: function(e) {
        // Событие change вызывается только при свойстве checked === true.
        this.setMod(this.__self._getRadioByElem(e.data.domElem), 'checked', 'yes');
    },

    _onPointerpress: function(e) {
        var elem = e.data.domElem;

        this.setMod(elem, 'pressed', 'yes')
            .bindToDoc('pointerrelease', function() {
                this.delMod(elem, 'pressed')
                    .unbindFromDoc('pointerrelease');
            });
    }
}, {
    live: function() {
        this.liveBindTo('radio', 'pointerclick', function(e) {
                this._onRadioClick(e.data.domElem, e);
            })
            .liveBindTo('control', 'change', function(e) {
                this._onChange(e);
            })
            .liveBindTo('radio', 'pointerover pointerout', function(e) {
                if(e.data.domElem[0].contains(e.relatedTarget)) {
                    return;
                } else if(e.type === 'pointerover') {
                    this._onRadioEnter(e);
                } else {
                    this._onRadioLeave(e);
                }
            })
            .liveBindTo('control', 'focusin focusout', function(e) {
                var radio = this.__self._getRadioByElem(e.data.domElem);

                this.setMod(radio, 'focused', e.type === 'focusin' ? 'yes' : '');

                // https://st.yandex-team.ru/ISL-1832
                // Prevent ios8+ from autoscroll/autozoom to the input on focus.
                BEM.blocks['i-ua'].ios >= 8 && e.preventDefault();
            })
            .liveBindTo('radio', 'pointerpress', function(e) {
                if(!this.hasMod(e.data.domElem, 'disabled')) {
                    this._onPointerpress(e);
                }
            });
    },

    /**
     * Позволяет получить __radio по какому-либо потомку этого элемента в DOM-дереве.
     * Метод статический, потому что никак не зависит от инстансов.
     *
     * @protected
     */
    _getRadioByElem: function(elem) {
        return elem.closest(this.buildSelector('radio'));
    }
});

/* end: ../../../libs/islands/common.blocks/radiobox/radiobox.js */
/* begin: ../../../libs/islands/common.blocks/util/__merge/util__merge.js */
(function() {
    var toString = Object.prototype.toString;

    function isObject(something) {
        return toString.call(something) === '[object Object]';
    }

    function merge(object, source, customizer) {
        var key, customized;

        object = Object(object);
        source = Object(source);

        for(key in source) {
            customized = customizer && customizer(object[key], source[key], key);

            if(customized !== undefined) {
                object[key] = customized;
            } else if(isObject(object[key]) && isObject(source[key])) {
                object[key] = merge(object[key], source[key], customizer);
            } else {
                object[key] = source[key];
            }
        }

        return object;
    }

    function mergeBemjson(object, source) {
        return merge(object, source, function(left, right, key) {
            if(key === 'mix') {
                return [].concat(left, right);
            }
        });
    }

    $.extend($.util, {
        merge: merge,
        mergeBemjson: mergeBemjson
    });
})();

/* end: ../../../libs/islands/common.blocks/util/__merge/util__merge.js */
/* begin: ../../../libs/islands/common.blocks/i-bem/__dom/_init/i-bem__dom_init_auto.js */
$(function() {
    BEM.afterCurrentEvent(function() {
        BEM.DOM.init();
    });
});

/* end: ../../../libs/islands/common.blocks/i-bem/__dom/_init/i-bem__dom_init_auto.js */
/* begin: ../../../libs/islands/common.blocks/modal/modal.js */
/**
 * Modal
 */
BEM.DOM.decl('modal', {
    /**
     * Генерируется перед появлением модального окна. В момент срабатывания события модификатор
     * `_visible_yes` еще не выставлен.
     *
     * @event modal#beforeOpen
     */

    /**
     * Генерируется после появления модального окна в момент, когда проиграна анимация открытия.
     * Если браузер не поддерживает CSS3-анимацию, событие будет вызвано в следующем тике после
     * выставления `_visible_yes`.
     *
     * @event modal#afterOpen
     */

    /**
     * Генерируется перед скрытием модального окна. В момент события модификатор `_visible_yes` еще не убран.
     *
     * @event modal#beforeClose
     */

    /**
     * Генерируется после скрытия модального окна в момент, когда проиграна анимация закрытия.
     * Если браузер не поддерживает CSS3-анимацию, событие будет вызвано в следующем тике после удаления `_visible`.
     *
     * @event modal#afterClose
     */

    /**
     * @private
     */
    onSetMod: {
        js: {
            inited: function() {
                this._popup = this.findBlockOn('popup2');
            }
        },

        visible: function(modName, modVal) {
            var eventName = modVal === 'yes' ? 'Open' : 'Close',
                content = this.elem('content'),

                // Нам нужно определить, что анимация есть именно на элементе __content, поэтому смотрим в его
                // Computed Style. Так мы можем более гибко узнать, нужно ли нам устанавливать обработчик на
                // завершение анимации.
                style = window.getComputedStyle ? window.getComputedStyle(content[0]) : content[0].currentStyle,
                animationEndEvent = parseFloat(style.animationDuration) > 0
                    ? 'animationend'
                    : parseFloat(style.webkitAnimationDuration) > 0 // В Chromium 31 и Safari 7 нужен префикс
                        ? 'webkitAnimationEnd'
                        : '',
                onAnimationEnd = function() {
                    this.trigger('after' + eventName);
                };

            this
                .trigger('before' + eventName)
                ._popup.setMod(modName, modVal);

            // Если анимация не поддерживается браузером или она не доступна (на данный момент анимация только
            // на desktop), то генерируем события afterClose/afterOpen просто в следующем тике.
            if(animationEndEvent) {
                content.one(animationEndEvent, onAnimationEnd.bind(this));
            } else {
                this.afterCurrentEvent(onAnimationEnd);
            }
        }
    },

    /**
     * @override
     */
    destruct: function() {
        this
            .delMod('visible')
            .__base.apply(this, arguments);
    },

    /**
     * Устанавливает контент.
     *
     * @param {String|jQuery} content
     * @returns {BEM.DOM} this
     */
    setContent: function(content) {
        BEM.DOM.update(this.elem('content'), content);
        return this;
    }
}, {
    live: true
});

/* end: ../../../libs/islands/common.blocks/modal/modal.js */
/* begin: ../../../libs/islands/desktop.blocks/modal/modal.js */
BEM.DOM.decl('modal', {
    onSetMod: {
        js: {
            inited: function() {
                this.__base.apply(this, arguments);
                this._enforceRepaint = this._enforceRepaint.bind(this);
            }
        },

        visible: {
            yes: function() {
                this.__base.apply(this, arguments);

                /* В IE есть проблемы с перерисовкой модального окна при изменении его размеров.
                 * Решается принудительной перерисовкой после изменения размеров блока.
                 * Чтобы хак затронул только IE, используем нестандартную возможность вешать resize на элемент.
                 * Работает только через attachEvent, и только с именем события onresize.
                 */
                if(window.attachEvent) {
                    this.elem('content')[0].attachEvent('onresize', this._enforceRepaint);
                }
            },

            '': function() {
                this.__base.apply(this, arguments);

                if(window.detachEvent) {
                    this.elem('content')[0].detachEvent('onresize', this._enforceRepaint);
                }
            }
        }
    },

    /**
     * @private
     */
    _enforceRepaint: function() {
        this.domElem[0].className += '';
    }
});

/* end: ../../../libs/islands/desktop.blocks/modal/modal.js */
/* begin: ../../../libs/islands/common.blocks/popup2/_autoclosable/popup2_autoclosable_yes.js */
BEM.DOM.decl({block: 'popup2', modName: 'autoclosable', modVal: 'yes'}, {
    onSetMod: {
        visible: {
            yes: function() {
                this.__self._visiblePopupsStack.unshift(this);

                // NOTE: afterCurrentEvent because of event bubbling to document
                this.afterCurrentEvent(function() {
                    this.domElem && this.bindToDoc('pointerclick', this._onDocClick);
                });

                this.__base.apply(this, arguments);
            },

            '': function() {
                var visiblePopupsStack = this.__self._visiblePopupsStack;

                visiblePopupsStack.splice(visiblePopupsStack.indexOf(this), 1);

                this.unbindFromDoc('pointerclick')
                    .__base.apply(this, arguments);
            }
        }
    },

    _onDocClick: function(e) {
        // Не закрываем попап, если клик был внутри его anchor'a.
        if(this.hasMod('target', 'anchor') &&
            (this._anchor[0] === e.target || this._anchor.find(e.target).length > 0)) {
            return;
        }

        if(this._preventHideByClick) {
            this._preventHideByClick = null;
        } else {
            this.delMod('visible');
        }
    }
}, {
    live: function() {
        BEM.DOM.doc.on('keydown', this._onDocKeyPress.bind(this));

        return this.__base();
    },

    /**
     * @private
     */
    _visiblePopupsStack: [],

    /**
     * @private
     */
    _onDocKeyPress: function(e) {
        if(BEM.blocks.keycodes.is(e.keyCode, 'ESC') && this._visiblePopupsStack.length) {
            this._visiblePopupsStack[0].delMod('visible');
        }
    }
});

/* end: ../../../libs/islands/common.blocks/popup2/_autoclosable/popup2_autoclosable_yes.js */
/* begin: ../../../libs/islands/common.blocks/button2/button2.js */
/**
 * @class button2
 * @extends control
 * @param {Object} params Параметры блока.
 * @param {String[]} [params.pressKeys] Клавиши, на которые должен реагировать блок.
 * @param {String[]} [params.prvntKeys] Клавиши, для которых делать preventDefault по событию keydown.
 * @param {String[]} [params.clickKeys] Клавиши, для которых генерировать БЭМ-событие click по событию keyup.
 */
BEM.DOM.decl({block: 'button2', baseBlock: 'control'}, {
    /**
     * Генерируется в момент клика по кнопке.
     *
     * @event button2#click
     * @param {Object} data Данные события.
     * @param {jQuery.Event} data.domEvent Оригинальное DOM-событие.
     */

    /**
     * Генерируется перед получением модификатора _pressed_yes.
     *
     * @event button2#press
     */

    /**
     * Генерируется перед снятием модификатора _pressed.
     *
     * @event button2#release
     */

    /**
     * Генерируется перед получением модификатора _checked_yes.
     *
     * @event button2#check
     */

    /**
     * Генерируется перед снятием модификатора _checked.
     *
     * @event button2#uncheck
     */

    onSetMod: {
        js: {
            inited: function() {
                this.__base.apply(this, arguments);
            }
        },

        pressed: {
            yes: function() {
                if(this.hasMod('disabled')) {
                    return false;
                }

                this.trigger('press');
            },

            '': function() {
                this.trigger('release');
            }
        },

        checked: {
            yes: function() {
                this.trigger('check')
                    .domElem.attr('aria-pressed', 'true');
            },

            '': function() {
                this.trigger('uncheck')
                    .domElem.attr('aria-pressed', 'false');
            }
        },

        disabled: {
            yes: function() {
                this.__base.apply(this, arguments);
                this.delMod('pressed');
            }
        },

        focused: {
            '': function() {
                this.__base.apply(this, arguments);
                this.delMod('pressed');
            }
        }
    },

    /**
     * Возвращает текст.
     *
     * @returns {String}
     */
    getText: function() {
        return this.elem('text').text();
    },

    /**
     * Устанавливает текст.
     *
     * @param {String} text
     * @returns {button2}
     */
    setText: function(text) {
        this.elem('text').text(text);
        return this;
    },

    /**
     * @private
     */
    _onClick: function(e) {
        this.trigger('click', {domEvent: e});
    },

    /**
     * @private
     */
    _onPointerpress: function(e) {
        this.setMod('pressed', 'yes')
            .bindToDoc('pointerrelease', this._onPointerrelease);
    },

    /**
     * @private
     */
    _onPointerrelease: function() {
        this.delMod('pressed')
            .unbindFromDoc('pointerrelease');
    },

    /**
     * @private
     */
    _onKeydown: function(e) {
        var keycode = e.keyCode,
            keycodes = BEM.blocks.keycodes;

        if(keycodes.is(keycode, this.params.pressKeys)) {
            this.setMod('pressed', 'yes');

            if(keycodes.is(keycode, this.params.prvntKeys)) {
                e.preventDefault();
            }
        }
    },

    /**
     * @private
     */
    _onKeyup: function(e) {
        var keycode = e.keyCode,
            keycodes = BEM.blocks.keycodes;

        if(keycodes.is(keycode, this.params.pressKeys)) {
            this.delMod('pressed');

            if(keycodes.is(keycode, this.params.clickKeys)) {
                this.trigger('click', {domEvent: e});
            }
        }
    },

    getDefaultParams: function() {
        return $.extend(this.__base(), {
            pressKeys: ['SPACE', 'ENTER'],
            prvntKeys: [],
            clickKeys: []
        });
    }
}, {
    live: function() {
        // При _disabled_yes выставляется css-свойство pointer-events:none.
        // Это гарантирует отсутствие событий pointerpress/pointerclick.
        // В качестве нормализации для браузеров, не поддерживающих pointer-events,
        // мы не вызываем обработчик при наличии _disabled_yes.
        this.liveBindTo('pointerpress', function(e) {
                this.hasMod('disabled') || this._onPointerpress(e);
            })
            .liveBindTo('pointerclick', function(e) {
                this.hasMod('disabled') || this._onClick(e);
            })
            .liveBindTo('keydown', function(e) {
                this._onKeydown(e);
            })
            .liveBindTo('keyup', function(e) {
                this._onKeyup(e);
            });

        return this.__base();
    }
});

/* end: ../../../libs/islands/common.blocks/button2/button2.js */
/* begin: ../../../libs/islands/desktop.blocks/button2/button2.js */
BEM.DOM.decl('button2', {
    onSetMod: {
        hovered: {
            yes: function() {
                return !this.hasMod('disabled');
            }
        },

        disabled: {
            yes: function() {
                this.__base.apply(this, arguments);
                this.delMod('hovered');
            }
        }
    },

    _onPointerenter: function() {
        this.setMod('hovered', 'yes');
    },

    _onPointerleave: function() {
        this.delMod('hovered');
    }
}, {
    live: function() {
        // Цепочка событий при двойном клике в IE8:
        // mousedown → mouseup → click → mouseup → dblclick
        // См. http://www.quirksmode.org/dom/events/click.html
        // Подписываемся на dblclick, чтобы кнопка реагировала на второй клик.
        (BEM.blocks['i-ua'].ie === 8) && this.liveBindTo('dblclick', function(e) {
            this.hasMod('disabled') || this._onClick(e);
        });

        // 1. В качестве нормализации для браузеров, не поддерживающих css-свойство
        //    pointer-events, не вызываем обработчик при наличии _disabled_yes.
        // 2. Проверяем, что pointerover/pointerout не случились внутри кнопки.
        //    Т.е. имитируем события pointerenter/pointerleave, которые не всплывают
        //    и непригодны для прямого использования в liveBindTo.
        //
        // Занимательный факт. В Opera 12 у потомков <button> не всплывает mouseover.
        // Подробнее:
        //   - http://jsbin.com/fahasekoxe/1/
        //   - http://jing.yandex-team.ru/files/karamadjong/2015-05-07_1102.swf?w=1278&h=350
        this.liveBindTo('pointerover pointerout', function(e) {
            if(this.hasMod('disabled') || this.domElem[0].contains(e.relatedTarget)) {
                return;
            }
            (e.type === 'pointerover') ? this._onPointerenter(e) : this._onPointerleave(e);
        });

        return this.__base();
    }
});

/* end: ../../../libs/islands/desktop.blocks/button2/button2.js */
/* begin: ../../../libs/islands/common.blocks/input/input.js */
BEM.DOM.decl('input', {

    /**
     * Генерируется при смене значения.
     *
     * @event input#change
     * @property {Object} [data]           Дополнительные параметры.
     * @property {String} [data.source]    Источник события. Например:
     *  - `clear` - если значение было очищено с помощью крестика;
     *  - `autocomplete` - если значение было изменено при перемещении по подсказкам саджеста;
     *  - `sample` - если значение было подставлено из примера.
     *
     * @property {Number} [data.itemIndex] Индекс подсказки, которая была выделена, если событие
     * сгенерировано при перемещении по подсказкам саджеста.
     */

    /**
     * Генерируется при получении фокуса.
     *
     * @event input#focus
     */

    /**
     * Генерируется при потере фокуса.
     *
     * @event input#blur
     */

    /**
     * @private
     */
    onSetMod: {

        js: {
            inited: function() {
                /**
                 * Текущее значение.
                 *
                 * @private
                 * @type {String}
                 */
                this._val = this.elem('control').val();
            }
        },

        disabled: {
            '*': function(modName, modVal) {
                this.elem('control').attr('disabled', modVal === 'yes');
            },

            yes: function() {
                this.delMod('focused');
            }
        },

        focused: function(modName, modVal) {
            if(this.hasMod('disabled', 'yes')) {
                return false;
            }

            var focused = (modVal === 'yes');

            focused ? this._focused || this._focus() : this._focused && this._blur();

            this.afterCurrentEvent(function() {
                this.trigger(focused ? 'focus' : 'blur');
            });
        }
    },

    /**
     * Проверяет, находится ли блок в отключенном состоянии.
     * Отключенное состояние характеризуется наличием модификатора `_disabled_yes`.
     *
     * @public
     * @returns {Boolean}
     */
    isDisabled: function() {
        return this.hasMod('disabled', 'yes');
    },

    /**
     * Устанавливает/возвращает текущее значение.
     *
     * Если передан параметр val, то устанавливает значение и возвращает экземпляр блока.
     * При этом генерирует событие `change`.
     *
     * Если метод вызван без параметров, то возвращает текущее значение.
     *
     * @public
     * @param {String} [val] Устанавливаемое значение.
     * @param {Object} [data] Дополнительные данные, которые будут переданы в обработчик события `change`.
     * @returns {BEM.DOM|String}
     */
    val: function(val, data) {
        var isVal = typeof val !== 'undefined',
            input = this.elem('control');

        if(isVal) {
            val = val === null ? '' : val.toString();
        } else {
            val = input.val();
        }

        if(this._val !== val) {
            this._val = val;

            if(input.val() !== val) {
                input.val(val);
            }

            this.trigger('change', data);
        }

        return isVal ? this : val;
    },

    /**
     * Возвращает/устанавливает имя нативного контрола.
     *
     * @public
     * @param {String} [val] Новое имя для контрола.
     * @returns {String|BEM.DOM}
     */
    name: function(val) {
        var control = this.elem('control');

        if(!arguments.length) {
            return control.attr('name');
        }

        control.attr('name', val);

        return this;
    },
    /**
     * Возвращает позицию курсора в текстовом поле.
     * @see http://stackoverflow.com/questions/4185821#4186100
     *
     * @public
     * @returns {Number}
     */
    getSelectionEnd: function() {
        var input = this.elem('control')[0],
            end = 0;
        if(typeof(input.selectionEnd) === 'number') {
            end = input.selectionEnd;
        } else {
            var range = document.selection.createRange();
            if(range && range.parentElement() === input) {
                var len = input.value.length,
                    textInputRange = input.createTextRange();
                textInputRange.moveToBookmark(range.getBookmark());

                var endRange = input.createTextRange();
                endRange.collapse(false);
                end = textInputRange.compareEndPoints('EndToEnd', endRange) > -1
                    ? len
                    : -textInputRange.moveEnd('character', -len);
            }
        }

        return end;
    },

    /**
     * Обработчик DOM-события `focus` на нативном контроле.
     *
     * @private
     * @returns {BEM.DOM}
     */
    _onFocus: function() {
        // Избавляемся от багов, когда при фокусе каретка помещается в непонятное место https://nda.ya.ru/3RSNwP.
        if(parseInt(BEM.blocks['i-ua'].ios, 10) >= 8 && !this.hasMod('type', 'textarea')) {
            var control = this.elem('control')[0];
            if(control.selectionStart === control.value.length) {
                control.scrollLeft = control.scrollWidth;
            }
        }

        this._focused = true;

        return this.setMod('focused', 'yes');
    },

    /**
     * Обработчик DOM-события `blur` на нативном контроле.
     *
     * @private
     * @returns {BEM.DOM}
     */
    _onBlur: function() {
        // https://st.yandex-team.ru/ISLCOMPONENTS-768
        if(this._returnFocus) {
            this.afterCurrentEvent(function() {
                this._focus();
            });
            return this;
        }

        if(this.hasMod(this.elem('clear'), 'pressed')) {
            return this;
        }

        this._focused = false;

        return this.delMod('focused');
    },

    /**
     * Передает фокус нативному контролу.
     *
     * @private
     */
    _focus: function() {
        if(this.hasMod('disabled', 'yes')) {
            return false;
        }

        this.elem('control').focus();
    },

    /**
     * Вызывает потерю фокуса нативным контролом.
     *
     * @private
     */
    _blur: function() {
        this._returnFocus = false;
        this.elem('control').blur();
    },

    /**
     * @private
     */
    _onIOSTouchStart: function(e) {
        if(!this.hasMod('type', 'textarea') && !this.hasMod('focused')) {
            e.preventDefault();
            this.setMod('focused', 'yes');
        }
    },

    /**
     * Уничтожает блок.
     *
     * @public
     */
    destruct: function() {
        // Принудительный сброс фокуса позволяет получить
        // корректное поведение при уничтожении
        // блока в фокусе
        this._blur();
        this.__base.apply(this, arguments);
    }
}, {
    live: function() {
        this.liveBindTo('control', 'focusin focusout', function(e) {
            this[e.type === 'focusin' ? '_onFocus' : '_onBlur'](e);
        });

        if(parseInt(BEM.blocks['i-ua'].ios, 10) >= 8) {
            this.liveBindTo('control', 'touchstart', function(e) {
                this._onIOSTouchStart(e);
            });
        }
    }
});

/* end: ../../../libs/islands/common.blocks/input/input.js */
/* begin: ../../../libs/islands/desktop.blocks/input/input.js */
(function() {
var instances = [],
    sysChannel,
    update = function() {
        instances.forEach(function(instance) {
            instance.val(instance.elem('control').val());
        });
    };

/**
 * Смена значения в нативном контроле отслеживается методом опроса.
 * Для этого используется событие `tick` из канала `sys`, реализованного в блоке `i-system`.
 *
 * @param {Object} [params] Параметры блока.
 * @param {Boolean} [params.autoFocus=false] Если `true`, то на инпут будет установлен фокус при инициализации.
 * @param {Boolean} [params.shortcut=false]  Если `true`, то включает шорткат перехода в в инпут (ctrl+стрелка вверх).
 */
BEM.DOM.decl('input', {

    onSetMod: {

        js: {

            inited: function() {
                this.__base.apply(this, arguments);

                // Сохраняем индекс в массиве инстансов чтобы потом быстро из него удалять
                this._instanceIndex = instances.push(this) - 1;

                var input = this.elem('control'),
                    activeElement = $.dom.getActiveElement(),
                    haveToSetAutoFocus = this.params.autoFocus && !activeElement.is('input, textarea');

                if(activeElement[0] === input[0] || haveToSetAutoFocus) {
                    this.setMod('focused', 'yes')._focused = true;
                }

                // Факт подписки
                if(!sysChannel) {
                    sysChannel = this.channel('sys')
                        .on({
                            tick: update,
                            idle: this._onSysIdle,
                            wakeup: this._onSysWakeup
                        });
                }

                // Шорткат для перехода в инпут - ctrl+стрелка вверх
                this.params.shortcut && this.bindToDoc('keydown', function(e) {
                    if(e.ctrlKey && e.which === BEM.blocks.keycodes.UP
                        && !$(e.target).is('input, textarea')) {
                        this.setMod('focused', 'yes');
                    }
                });
            }

        }

    },

    _focus: function() {
        if(this.__base() === false) {
            return false;
        }
        // NOTE: Нормализация установки фокуса для IE
        var input = this.elem('control')[0];
        if(input.createTextRange && !input.selectionStart) {
            var range = input.createTextRange();
            range.move('character', input.value.length);
            range.select();
        }
    },

    _onSysIdle: function() {
        sysChannel.un('tick', update);
    },

    _onSysWakeup: function() {
        sysChannel.on('tick', update);
    },

    destruct: function() {
        this.__base.apply(this, arguments);

        this.params.shortcut && this.unbindFromDoc('keydown');

        instances.splice(this._instanceIndex, 1);

        instances.slice(this._instanceIndex).forEach(function(instance) {
            instance._instanceIndex--;
        });

        sysChannel.un({
            idle: this._onSysIdle,
            wakeup: this._onSysWakeup
        });
    },

    _onPointerenter: function(e) {
        this.setMod('hovered', 'yes');
    },

    _onPointerleave: function(e) {
        this.delMod('hovered');
    }
}, {
    live: function() {
        this.liveBindTo('box', 'pointerover pointerout', function(e) {
            if(this.hasMod('disabled') || this.elem('box')[0].contains(e.relatedTarget)) {
                return;
            }
            (e.type === 'pointerover') ? this._onPointerenter(e) : this._onPointerleave(e);
        });

        return this.__base();
    }
});
})();

/* end: ../../../libs/islands/desktop.blocks/input/input.js */
/* begin: ../../../libs/islands/common.blocks/input/__clear/input__clear.js */
BEM.DOM.decl('input', {
    onSetMod: {
        js: {
            inited: function() {
                this.__base.apply(this, arguments);

                this.on('change', this._updateClear)
                    // Дополнительно проверяем необходимость отображения крестика на случай включенного автокомплита
                    ._updateClear();
            }
        }
    },

    /**
     * Обработчик клика на очищающем крестике.
     * Очищает значение и устанавливает фокус на контрол.
     *
     * @private
     * @returns {BEM.DOM}
     */
    _onClearClick: function() {
        this.trigger('clear');
        this.removeInsets && this.removeInsets();

        return this
            .clearInput({source: 'clear'})
            ._focus();
    },

    /**
     * Очищает значение в поле ввода.
     *
     * Генерирует событие `change`.
     *
     * @public
     * @param  {Object} data Дополнительные данные, которые будут переданы в обработчик события `change`.
     * @returns {BEM.DOM}
     */
    clearInput: function(data) {
        this.val('', data);

        return this;
    },

    /**
     * Скрывает элемент clear при отсутствии текста в поле ввода, при наличии текста – показывает.
     *
     * @private
     * @returns {BEM.DOM}
     */
    _updateClear: function() {
        return this.toggleMod(this.elem('clear'), 'visibility', 'visible', Boolean(this._val));
    }
}, {
    live: function() {
        this.liveBindTo('clear', 'pointerpress', function(e) {
                this.setMod(this.elem('clear'), 'pressed', 'yes');
            })
            .liveBindTo('clear', 'pointerclick', function() {
                this.delMod(this.elem('clear'), 'pressed');
                this._onClearClick();
            })
            .liveBindTo('control', 'paste', function() {
                // Изменяем отступ справа у контрола перед вставкой текста https://st.yandex-team.ru/ISL-2024
                this.setMod(this.elem('clear'), 'visibility', 'visible');
            });

        return this.__base();
    }
});

/* end: ../../../libs/islands/common.blocks/input/__clear/input__clear.js */
/* begin: ../../../libs/islands/common.blocks/tabs/tabs.js */
// NOTE: Этот файл описывает общий публичный интерфейс. Реализация содержится в `_control_*.js`
BEM.DOM.decl('tabs', {

    /**
     * Генерируется при смене активной вкладки.
     *
     * @event tabs#change
     * @param {Object} data              Данные события.
     * @param {Number} data.currentIndex Индекс активной вкладки.
     * @param {Number} data.prevIndex    Индекс предыдущей активной вкладки.
     */

    /**
     * Возвращает количество вкладок.
     *
     * @public
     * @returns {Number}
     */
    getCount: function() {
        return this.elem('tab').length;
    },

    /**
     * Активирует вкладку по индексу.
     *
     * @public
     * @param {Number} index Индекс вкладки. Индексация начинается от 0.
     * @returns {BEM.DOM.tabs}
     */
    activate: /* istanbul ignore next: default implementation */ function(index) {
        return this;
    },

    /**
     * Возвращает индекс активной вкладки или -1, если нет активной вкладки. Индексация начинается от 0.
     *
     * @public
     * @returns {Number}
     */
    getActive: /* istanbul ignore next: default implementation */ function() {
        return -1;
    },

    /**
     * Делает вкладку неактивной.
     *
     * @public
     * @param {Number} index Индекс вкладки. Индексация начинается от 0.
     * @returns {BEM.DOM.tabs}
     */
    disable: /* istanbul ignore next: default implementation */ function(index) {
        return this;
    },

    /**
     * Делает вкладку активной.
     *
     * @public
     * @param {Number} index Индекс вкладки. Индексация начинается от 0.
     * @returns {BEM.DOM.tabs}
     */
    enable: /* istanbul ignore next: default implementation */ function(index) {
        return this;
    },

    /**
     * Проверяет, отключена ли вкладка.
     *
     * @public
     * @param {Number} index Индекс вкладки. Индексация начинается от 0.
     */
    isDisabled: /* istanbul ignore next: default implementation */ function(index) {},

    /**
     * Обработчик смены значения в дочернем контроле.
     *
     * @private
     * @param {$.Event} e
     * @param {Object} data
     */
    _onControlChange: /* istanbul ignore next: default implementation */ function(e, data) {}

}, {
    /**
     * Возвращает список блоков, которые должны вызывать инициализацию блока `tabs` своим событием `change`.
     * Доопределите этот метод для добавления блоков.
     *
     * @protected
     * @returns {String[]}
     */
    getSupportedControls: function() {
        return ['tabs-menu', 'radio-button'];
    },

    live: function() {
        this.getSupportedControls().forEach(function(block) {
            BEM.blocks[block] && this.liveInitOnBlockInsideEvent('change', block, function(e, data) {
                this._onControlChange(e, data);
            });
        }, this);
    }
});

/* end: ../../../libs/islands/common.blocks/tabs/tabs.js */
/* begin: ../../../libs/islands/common.blocks/popup2/_target/popup2_target_anchor.js */
(function($) {
BEM.DOM.decl({block: 'popup2', modName: 'target', modVal: 'anchor'}, {
    /**
     * @private
     */
    onSetMod: {
        js: {
            inited: function() {
                this.__base.apply(this, arguments);

                this._anchor = null;
                this._anchorParents = null;
                this._destructor = null;
                this._isAnchorVisible = undefined;
                this._updateIsAnchorVisible = $.throttle(
                    this._updateIsAnchorVisible,
                    this.__self.UPDATE_TARGET_VISIBILITY_THROTTLING_INTERVAL,
                    this);
            }
        },

        visible: {
            yes: function() {
                if(!this._anchor) {
                    throw new Error('Can\'t show popup without anchor');
                }

                this._anchorParents = this._anchor.parents();
                this._bindToAnchorParents();

                this.__base.apply(this, arguments);
            },

            '': function() {
                this.__base.apply(this, arguments);

                this._unbindFromAnchorParents();
                this._anchorParents = null;
                this._isAnchorVisible = undefined;
            }
        }
    },

    /**
     * @protected
     */
    destruct: function() {
        this._unbindFromDestructor();

        this.__base.apply(this, arguments);
    },

    /**
     * Устанавливает цель, относительно которой нужно открываться.
     *
     * @param {jQuery|BEM.DOM} anchor
     * @returns {BEM.DOM.popup2} this
     */
    setAnchor: function(anchor) {
        this._unbindFromAnchorParents()
            ._unbindFromParentPopup()
            ._unbindFromDestructor();

        this._anchor = anchor instanceof BEM.DOM ?
            anchor.domElem :
            anchor;

        this._destructor = beminize(this._anchor, '_' + this.__self.getName() + '-destructor');
        this._isAnchorVisible = undefined;

        this._bindToDestructor();

        if(this.hasMod('visible', 'yes')) {
            this._anchorParents = this._anchor.parents();
            this._recaptureZIndex()
                ._bindToAnchorParents()
                ._bindToParentPopup()
                .redraw();
        } else {
            this._anchorParents = null;
            this._zIndexGroupLevel = null;
        }

        return this;
    },

    /**
     * @override
     * @private
     */
    _calcTargetDimensions: function() {
        var anchor = this._anchor,
            anchorPos = this._getOffsetOf(anchor);

        return {
            left: anchorPos.left,
            top: anchorPos.top,
            width: anchor.outerWidth(),
            height: anchor.outerHeight()
        };
    },

    /**
     * Возвращает позицию элемента относительно начала страницы с учетом ошибок IE на Windows Phone.
     * @see https://st.yandex-team.ru/ISLCOMPONENTS-1627
     *
     * @private
     * @param {jQuery} elem
     * @returns {Object}
     */
    _getOffsetOf: function(elem) {
        var offset = elem.offset();

        // В IE8 нет pageYOffset, но там этот фикс и не нужен.
        if('pageYOffset' in window) {
            // Обычно эти разности равны 0, так что не IE и не заметит.
            offset.top -= (window.pageYOffset - (document.documentElement.scrollTop || document.body.scrollTop));
            offset.left -= (window.pageXOffset - (document.documentElement.scrollLeft || document.body.scrollLeft));
        }

        return offset;
    },

    /**
     * @override
     * @private
     */
    _calcDrawingCss: function(drawingParams) {
        if(typeof this._isAnchorVisible === 'undefined') {
            this._isAnchorVisible = this._calcIsAnchorVisible();
        }

        return $.extend(
            this.__base(drawingParams),
            {display: this._isAnchorVisible ? '' : 'none'});
    },

    /**
     * Вычисляет, видим ли сейчас anchor попапа.
     * @private
     * @returns {Boolean}
     */
    _calcIsAnchorVisible: function() {
        var anchor = this._anchor,
            anchorOffset = this._getOffsetOf(anchor),
            anchorLeft = anchorOffset.left,
            anchorTop = anchorOffset.top,
            anchorRight = anchorLeft + anchor.outerWidth(),
            anchorBottom = anchorTop + anchor.outerHeight(),
            direction = this.getMod('direction'),
            vertBorder = Math.floor(this._checkDirection(direction, 'top') ? anchorTop : anchorBottom),
            horizBorder = Math.floor(this._checkDirection(direction, 'left') ? anchorLeft : anchorRight),
            res = true;

        this._anchorParents.each(function(idx, parent) {
            if(parent.tagName === 'BODY') {
                return false;
            }

            parent = $(parent);

            var re = /scroll|hidden|auto/,
                hasOverflowY = re.test(parent.css('overflow-y')),
                hasOverflowX = re.test(parent.css('overflow-x'));

            if(hasOverflowY || hasOverflowX) {
                var parentOffset = this._getOffsetOf(parent),
                    parentTopOffset = Math.floor(parentOffset.top);
                if(vertBorder < parentTopOffset || parentTopOffset + parent.outerHeight() < vertBorder) {
                    res = false;
                    return res;
                }

                var parentLeftOffset = Math.floor(parentOffset.left);
                res = horizBorder >= parentLeftOffset && parentLeftOffset + parent.outerWidth() >= horizBorder;
                return res;
            }
        }.bind(this));

        return res;
    },

    /**
     * @private
     */
    _calcZIndexGroupLevel: function() {
        var res = this.__base.apply(this, arguments);

        return this._destructor.findBlocksOutside('z-index-group').reduce(function(res, zIndexGroup) {
            return res + Number(zIndexGroup.getMod('level'));
        }, res);
    },

    /**
     * @private
     */
    _bindToAnchorParents: function() {
        return this.bindTo(this._anchorParents, 'scroll', this._onAnchorParentsScroll);
    },

    /**
     * @private
     */
    _unbindFromAnchorParents: function() {
        this._anchorParents && this.unbindFrom(this._anchorParents, 'scroll');
        return this;
    },

    /**
     * @private
     */
    _onAnchorParentsScroll: function() {
        this.redraw()
            ._updateIsAnchorVisible();
    },

    /**
     * @override
     * @private
     */
    _onWinScollAndResize: function() {
        this.__base.apply(this, arguments);
        this._updateIsAnchorVisible();
    },

    /**
     * Скрывает попап, если anchor не видим (ушел за полосы прокрутки) и наоборот.
     * @private
     */
    _updateIsAnchorVisible: function() {
        var isAnchorVisible = this._calcIsAnchorVisible();
        if(isAnchorVisible !== this._isAnchorVisible) {
            this._isAnchorVisible = isAnchorVisible;
            this.redraw();
        }
    },

    /**
     * @private
     */
    _bindToDestructor: function() {
        this._destructor.on('destruct', this._onPopupAnchorDestruct, this);
        return this;
    },

    /**
     * @private
     */
    _unbindFromDestructor: function() {
        this._destructor && this._destructor.un('destruct', this._onPopupAnchorDestruct, this);
        return this;
    },

    /**
     * @private
     */
    _onPopupAnchorDestruct: function() {
        this.domElem && BEM.DOM.destruct(this.domElem);
    },

    /**
     * @private
     */
    _getParentPopup: function() {
        if(this._parentPopup === undefined) {
            this._parentPopup = this.findBlockOutside(this._anchor, this.__self.getName());
        }

        return this._parentPopup;
    }
}, {
    /**
     * @private
     */
    UPDATE_TARGET_VISIBILITY_THROTTLING_INTERVAL: 100
});

// NOTE: этот "приватный" блок примешивается к цели раскрытия, и бросает `destruct`, когда она уничтожается.
// Благодаря этому мы можем уничтожать попап, когда уничтожается его цель.
// BEMDOM объявляется, чтобы не ломать сборку jsdoc.
var BEMDOM = BEM.DOM;
BEMDOM.decl('_popup2-destructor', {
    destruct: function() {
        this.trigger('destruct');

        this.__base.apply(this, arguments);
    }
});

/**
 * Добавляет DOM-узлу нужные классы и инициализирует на ней блок.
 *
 * @param {jQuery} elem
 * @param {String} block
 * @returns {BEM.DOM}
 */
function beminize(elem, block) {
    return elem.addClass('i-bem ' + block).bem(block);
}
})(jQuery);

/* end: ../../../libs/islands/common.blocks/popup2/_target/popup2_target_anchor.js */
/* begin: ../../../libs/islands/common.blocks/popup2/_theme/popup2_theme_normal.js */
/* istanbul ignore next: Эти параметры для темы тестируются в gemini */
BEM.DOM.decl({block: 'popup2', modName: 'theme', modVal: 'normal'}, {
    getDefaultParams: function() {
        return $.extend(
            this.__base(),
            {
                mainOffset: 5,
                viewportOffset: 5
            });
    }
});

/* end: ../../../libs/islands/common.blocks/popup2/_theme/popup2_theme_normal.js */
/* begin: ../../../libs/islands/common.blocks/link/link.js */
BEM.DOM.decl({block: 'link', baseBlock: 'control'}, {
    onSetMod: {
        hovered: {
            yes: function() {
                return !this.hasMod('disabled');
            }
        },

        pressed: {
            yes: function() {
                return !this.hasMod('disabled');
            }
        },

        disabled: {
            '': function() {
                this.__base.apply(this, arguments);
                this.domElem.attr('href', this._url);
            },

            yes: function() {
                this.__base.apply(this, arguments);

                this._url = this.domElem.attr('href');

                // 1. Чтобы нельзя было перейти из контекстного меню.
                // 2. Чтобы не возиться с Opera 12, которая не умеет pointer-events:none.
                this.domElem.removeAttr('href');

                this.delMod('pressed');
            }
        }
    },

    _onPointerpress: function(e) {
        this.setMod('pressed', 'yes')
            .bindToDoc('pointerrelease', this._onPointerrelease);
    },

    _onPointerrelease: function(e) {
        this.delMod('pressed')
            .unbindFromDoc('pointerrelease');
    }
}, {
    live: function() {
        this
            .liveBindTo('pointerpress', function(e) {
                this.hasMod('disabled') || this._onPointerpress(e);
            });

        return this.__base();
    }
});

/* end: ../../../libs/islands/common.blocks/link/link.js */
/* begin: ../../../libs/islands/desktop.blocks/link/link.js */
BEM.DOM.decl('link', {
    onSetMod: {
        hovered: {
            yes: function() {
                return !this.hasMod('disabled');
            }
        },

        disabled: {
            yes: function() {
                this.__base.apply(this, arguments);

                this.delMod('hovered');
            }
        }
    },

    _onPointerenter: function(e) {
        this.setMod('hovered', 'yes');
    },

    _onPointerleave: function(e) {
        this.delMod('hovered');
    }
}, {
    live: function() {
        this.liveBindTo('pointerover pointerout', function(e) {
                if(this.hasMod('disabled') || this.domElem[0].contains(e.relatedTarget)) {
                    return;
                }

                (e.type === 'pointerover') ? this._onPointerenter(e) : this._onPointerleave(e);
            });

        return this.__base.apply(this, arguments);
    }
});

/* end: ../../../libs/islands/desktop.blocks/link/link.js */
/* begin: ../../../libs/islands/common.blocks/button2/_type/button2_type_link.js */
BEM.DOM.decl({block: 'button2', modName: 'type', modVal: 'link'}, {
    onSetMod: {
        js: {
            inited: function() {
                this.__base.apply(this, arguments);
                this._url = this.params._url;
            }
        },

        disabled: {
            '': function() {
                this.__base.apply(this, arguments);
                this.domElem.attr('href', this._url);
            },

            yes: function() {
                this.__base.apply(this, arguments);

                // - Чтобы по ссылке нельзя было перейти из контекстного меню.
                // - Чтобы не возиться с Opera 12, которая не умеет pointer-events:none.
                this.domElem.removeAttr('href');
            }
        }
    },

    /**
     * Возвращает href.
     *
     * @returns {String}
     */
    getUrl: function() {
        return this._url;
    },

    /**
     * Устанавливает href.
     * Если кнопка имеет _disabled_yes, то новый href установится только после снятия _disabled.
     *
     * @param {String} url
     * @returns {button2}
     */
    setUrl: function(url) {
        this._url = url;
        if(!this.hasMod('disabled')) {
            this.domElem.attr('href', url);
        }
        return this;
    },

    getDefaultParams: function() {
        return $.extend(this.__base(), {
            pressKeys: ['ENTER'] // Браузеры переходят по ссылке только по ENTER.
        });
    }
});

/* end: ../../../libs/islands/common.blocks/button2/_type/button2_type_link.js */
/* begin: ../../../libs/islands/desktop.blocks/button2/_type/button2_type_link.js */
BEM.DOM.decl({block: 'button2', modName: 'type', modVal: 'link'}, {}, {
    live: function() {
        // Оторвать после закрытия https://st.yandex-team.ru/ISL-2076
        this.liveBindTo('dragend', function(e) {
            if(this.hasMod('type', 'link') && !this.hasMod('disabled')) {
                this.delMod('pressed');
            }
        });
        return this.__base();
    }
});

/* end: ../../../libs/islands/desktop.blocks/button2/_type/button2_type_link.js */
/* begin: ../../../libs/islands/desktop.blocks/modal/_theme/modal_theme_normal.js */
BEM.DOM.decl({block: 'modal', modName: 'theme', modVal: 'normal'}, {
    onSetMod: {
        visible: {
            yes: function() {
                this.setMod('has-animation', 'yes')
                    .__base.apply(this, arguments);
            }
        }
    }
});

/* end: ../../../libs/islands/desktop.blocks/modal/_theme/modal_theme_normal.js */
/* begin: ../../../libs/islands/common.blocks/modal/_autoclosable/modal_autoclosable_yes.js */
BEM.DOM.decl({block: 'modal', modName: 'autoclosable', modVal: 'yes'}, {
    onSetMod: {
        js: {
            inited: function() {
                this.__base.apply(this, arguments);
                this._preventHideByClick = false;
            }
        },
        visible: {
            yes: function() {
                this.__base.apply(this, arguments);

                this.bindTo('content', 'pointerdown pointerclick', this._setPreventHideByClick)
                    .bindTo('pointerclick', this._onPointerClick)
                    ._popup.on('beforeClose', this._onPopupClose, this);
            },

            '': function() {
                this.__base.apply(this, arguments);

                this.unbindFrom('content', 'pointerdown pointerclick')
                    .unbindFrom('pointerclick')
                    ._popup.un('beforeClose', this._onPopupClose, this);
            }
        }
    },

    /**
     * @private
     */
    _setPreventHideByClick: function(e) {
        this._preventHideByClick = true;
    },

    /**
     * @private
     */
    _onPointerClick: function(e) {
        if(!this._preventHideByClick) {
            this.delMod('visible');
        }

        this._preventHideByClick = false;
    },

    /**
     * @private
     */
    _onPopupClose: function() {
        this.delMod('visible');
    }
});

/* end: ../../../libs/islands/common.blocks/modal/_autoclosable/modal_autoclosable_yes.js */
/* begin: ../../common.blocks/tabs/_control/tabs_control_tab.js */
BEM.DOM.decl({ block: 'tabs', modName: 'control', modVal: 'tab' }, {
    onSetMod: {
        js: {
            inited: function inited() {
                // this.__base.apply(this, arguments);
                this._tabs = $(this.domElem).find('.tabs__tab').map(function () {
                    return $(this);
                });
            }
        }
    },

    activate: function activate(index) {
        this.setMod(this._tabs[index], 'active', 'yes');

        return this;
    },

    deactivate: function deactivate(index) {
        this.delMod(this._tabs[index], 'active');

        return this;
    },

    getActive: function getActive() {
        return this.getMod(this.elem('tab', 'active', 'yes'), 'n');
    },

    indexOfTab: function indexOfTab(tab) {
        return this.getMod(tab, 'n');
    },

    _onControlChange: function _onControlChange(e, data) {
        data.current.attr('aria-selected', true);
        data.prev.attr('aria-selected', false);

        this.trigger('change', {
            currentIndex: data.currentIndex,
            prevIndex: data.prevIndex
        });
    }

}, {
    live: function live() {
        this.liveBindTo('tab', 'click', function (e) {
            var current = e.data.domElem,
                prev = this.elem('tab', 'active', 'yes'),
                currentIndex = this.indexOfTab(current),
                prevIndex = this.indexOfTab(prev);

            this.activate(currentIndex);
            this.deactivate(prevIndex);

            this._onControlChange(e, {
                current: current,
                prev: prev,
                currentIndex: currentIndex,
                prevIndex: prevIndex
            });
        });
    }
});
/* end: ../../common.blocks/tabs/_control/tabs_control_tab.js */
